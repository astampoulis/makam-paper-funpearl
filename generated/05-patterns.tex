\section{Where our hero Hagop adds pattern matching on his
own}\label{where-our-hero-hagop-adds-pattern-matching-on-his-own}

\begin{scenecomment}
(Our hero Roza had a meeting with another student, so Hagop is back at his
office, trying to work out on his own how to encode patterns. He is fairly
confident at this point that having explicit support for single-variable
binding is enough to model most complicated forms of binding, especially when making use of
polymorphism and GADTs.)
\end{scenecomment}

\identNormal
\heroSTUDENT{} OK, so let's implement simple patterns and pattern-matching
like in ML\ldots{} First let's determine the right binding structure.
For a branch like:

\begin{verbatim}
| cons(hd, tl) \ensuremath{\to} ... hd .. tl ...
\end{verbatim}

the pattern introduces 2 variables, \texttt{hd} and \texttt{tl}, which
the body of the branch can refer to. But we can't really refer to those
variables in the pattern itself, at least for simple
patterns\footnote{There are cases where that's not the case, like in or-patterns in some ML dialects, or in dependent pattern matching, where consequent uses of the same variable perform an exact match rather than unification. We choose to omit the handling of cases like those in the present work for presentation purposes.}\ldots{}.
So there's no binding going on really within the pattern; instead, once
we figure out how many variables a pattern introduces, we can do the
actual binding all at once, when we get to the body of the branch:

\begin{verbatim}
branch(pattern, bind [# of variables in pattern].body)
\end{verbatim}

So we could write the above branch in Makam like this:

\begin{verbatim}
branch(
  patt_cons patt_var patt_var,
  bind (fun hd \ensuremath{\Rightarrow} bind (fun tl \ensuremath{\Rightarrow} body (.. hd .. tl ..))))
\end{verbatim}

We do have to keep the order of variables consistent somehow, so
\texttt{hd} here should refer to the first occurrence of
\texttt{patt\_var}, and \texttt{tl} to the second. Based on these, I am
thinking that the type of \texttt{branch} should be something like:

\begin{verbatim}
branch : (Pattern: patt N) (Vars_Body: vbindmany term N term) \ensuremath{\to} ...
\end{verbatim}

Wait, before I get into the weeds let me just set up some things. First,
let's add a simple base type, say \texttt{nat}s, to have something to
work with as an example. I'll prefix their names with \texttt{o} for
``object language,'' so as to avoid ambiguity. And I will also add a
\texttt{case\_or\_else} construct, standing for a single-branch
pattern-match construct. It should be easy to extend to a
multiple-branch construct, but I want to keep things as simple as
possible. I'll inline what I had written for \texttt{branch} above into
the definition of \texttt{case\_or\_else}.

\begin{verbatim}
onat : typ. ozero : term. osucc : term \ensuremath{\to} term.
typeof ozero onat. typeof (osucc N) onat :- typeof N onat.
eval ozero ozero. eval (osucc E) (osucc V) :- eval E V.
\end{verbatim}

\begin{verbatim}
case_or_else :
  (Scrutinee: term)
  (Patt: patt N) (Vars_Body: vbindmany term N term)
  (Else: term) \ensuremath{\to} term.
\end{verbatim}

Now for the typing rule -- it will be something like this:

\begin{verbatim}
typeof (case_or_else Scrutinee Pattern Vars_Body Else) BodyT :-
  typeof Scrutinee T,
  typeof_patt Pattern T VarTypes,
  vopenmany Vars_Body (pfun vars body \ensuremath{\Rightarrow}
    vassumemany typeof vars VarTypes (typeof body BodyT)),
  typeof Else BodyT.
\end{verbatim}

Right, so when checking a pattern, we'll have to determine both what
type of scrutinee it matches, as well as the types of the variables that
it contains. We will also need \texttt{vassumemany} that is just like
\texttt{assumemany} from before but which takes \texttt{vector}
arguments instead of \texttt{list}.

\begin{verbatim}
typeof_patt : [N] patt N \ensuremath{\to} typ \ensuremath{\to} vector typ N \ensuremath{\to} prop.
vassumemany : [N] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} vector A N \ensuremath{\to} vector B N \ensuremath{\to} prop \ensuremath{\to} prop.
(...)
\end{verbatim}

Now, I can just go ahead and define the patterns, together with their
typing relation, \texttt{typeof\_patt}.

Let me just work one by one for each pattern.

\begin{verbatim}
patt_var : patt (succ zero).
typeof_patt patt_var T (vcons T vnil).
\end{verbatim}

OK, that's how we'll write pattern variables, introducing a single
variable of a specific \texttt{typ} into the body of the branch. And the
following should be good for the \texttt{onat}s I defined earlier.

\begin{verbatim}
patt_ozero : patt zero.
typeof_patt patt_ozero onat vnil.

patt_osucc : patt N \ensuremath{\to} patt N.
typeof_patt (patt_osucc P) onat VarTypes :- typeof_patt P onat VarTypes.
\end{verbatim}

A wildcard pattern will match any value and should not introduce a
variable into the body of the branch.

\begin{verbatim}
patt_wild : patt zero.
typeof_patt patt_wild T vnil.
\end{verbatim}

OK, and let's do patterns for our n-tuples\ldots{}. I guess I'll need a
type for lists of patterns too.

\begin{verbatim}
patt_tuple : pattlist N \ensuremath{\to} patt N.
typeof_patt (patt_tuple PS) (product TS) VarTypes :-
  typeof_pattlist PS TS VarTypes.
pattlist : (N: type) \ensuremath{\to} type.
pnil : patt zero.
pcons : patt N \ensuremath{\to} pattlist N' \ensuremath{\to} pattlist (N + N').
\end{verbatim}

Uh-oh\ldots{} don't think I can do that
\texttt{N\ +\ N\textquotesingle{}} really. In this \texttt{pcons} case,
my pattern basically looks like \texttt{(P,\ ...PS)}; and I want the
overall pattern to have as many variables as \texttt{P} and \texttt{PS}
combined. But the GADTs support in \lamprolog seems to be quite basic. I
do not think there's any notion of type-level functions like
plus\ldots{}.

However\ldots{} maybe I can work around that, if I change \texttt{patt}
to include an ``accumulator'' argument, say \texttt{NBefore}. Each
constructor for patterns will now define how many pattern variables it
adds to that accumulator, yielding \texttt{NAfter}, rather than defining
how many pattern variables it includes\ldots{} like this:

\begin{verbatim}
patt, pattlist : (NBefore: type) (NAfter: type) \ensuremath{\to} type.
patt_var : patt N (succ N).
patt_ozero : patt N N.
patt_osucc : patt N N' \ensuremath{\to} patt N N'.
patt_wild : patt N N.
patt_tuple : pattlist N N' \ensuremath{\to} patt N N'.

pnil : pattlist N N.
pcons : patt N N' \ensuremath{\to} pattlist N' N'' \ensuremath{\to} pattlist N N''.
\end{verbatim}

Yes, I think that should work. I have a little editing to do in my
existing predicates to use this representation instead. For top-level
patterns, we should always start with the accumulator being
\texttt{zero}\ldots{}

\begin{verbatim}
case_or_else :
  (Scrutinee: term)
  (Patt: patt zero N) (Vars_Body: vbindmany term N term)
  (Else: term) \ensuremath{\to} term.
\end{verbatim}

I think I'll also have to change \texttt{typeof\_patt}, so that it
includes an accumulator argument of its own:

\begin{verbatim}
typeof_patt : [NBefore NAfter]
  patt NBefore NAfter \ensuremath{\to} typ \ensuremath{\to}
  vector typ NBefore \ensuremath{\to} vector typ NAfter \ensuremath{\to} prop.

typeof (case_or_else Scrutinee Pattern Vars_Body Else) BodyT :-
  typeof Scrutinee T,
  typeof_patt Pattern T vnil VarTypes,
  vopenmany Vars_Body (pfun vars body \ensuremath{\Rightarrow}
    vassumemany typeof vars VarTypes (typeof body BodyT)),
  typeof Else BodyT.
\end{verbatim}

All right, let's proceed to the typing rules for patterns themselves:

\begin{verbatim}
typeof_patt patt_var T VarTypes VarTypes' :-
  vsnoc VarTypes T VarTypes'.
\end{verbatim}

OK, here I need \texttt{vsnoc} to add an element to the end of a vector.
That should yield the correct order for the types of pattern variables;
I am visiting the pattern left-to-right after all.

\begin{verbatim}
vsnoc : [N] vector A N \ensuremath{\to} A \ensuremath{\to} vector A (succ N) \ensuremath{\to} prop.
vsnoc vnil Y (vcons Y vnil).
vsnoc (vcons X XS) Y (vcons X XS_Y) :- vsnoc XS Y XS_Y.
\end{verbatim}

The rest should be easy to adapt\ldots{}.

\begin{scenecomment}
(Our hero finishes adapting the rest of the rules for \texttt{typeof\_patt},
which are available in the unabridged version of this story. After
trying a few queries, he is convinced that his implementation of
pattern matching works well. The next day, he shows his work to Roza.)
\end{scenecomment}

\identDialog

\heroADVISOR{} That's great! I understand that this was a little tricky, but
still, it was not too bad, right? Actually, I know of one thing that is
quite simple to do: the evaluation rule. On paper we typically write
something roughly like:

\vspace{-1.5em}\begin{mathpar}
\inferrule{e_1 \Downarrow v_1 \\ \texttt{match}(p, v_1) \leadsto \sigma \\ e_2[\sigma/xs] \Downarrow v_2}
          {\texttt{case\_or\_else}(e_1, p \mapsto xs.e_2, e_3) \Downarrow v_2}

\inferrule{e_1 \Downarrow v_1 \\ \texttt{match}(p, v_1) \not\leadsto \\ e_3 \Downarrow v_3}
          {\texttt{case\_or\_else}(e_1, p \mapsto xs.e_2, e_3) \Downarrow v_3}
\end{mathpar}

So \texttt{match} tries to unify a pattern with a term and yields a
substitution \(\sigma\) for the pattern variables if successful, which
is then applied to the body of the branch. If there is no \texttt{match}
to be found, then we use the \texttt{else} branch.

\heroSTUDENT{} Hmm\ldots{} so do we need two predicates, one for the case
where the \texttt{match} is successful and one to check that a pattern
\emph{does not} match a scrutinee?

\heroADVISOR{} Actually we could have a single \texttt{match} predicate. And
we can use the logical \texttt{if-then-else} construct for the two
cases, which we have not seen so far. Let me write down the evaluation
rule, and I'll explain:

\begin{verbatim}
match : [NBefore NAfter]
  (Pattern: patt NBefore NAfter) (Scrutinee: term)
  (SubstBefore: vector term NBefore) (SubstAfter: vector term NAfter) \ensuremath{\to}
  prop.
eval (case_or_else Scrutinee Pattern Body Else) V' :-
  eval Scrutinee V,
  if (match Pattern V vnil Subst)
  then (vapplymany Body Subst Body', eval Body' V')
  else (eval Else V').
\end{verbatim}

The \texttt{if-then-else} construct behaves as follows: when there is at
least one way to prove the condition, it proceeds to the \texttt{then}
branch, otherwise it goes to the \texttt{else} branch. Pretty standard,
really. It is one thing that the Prolog cut statement, \texttt{!}, is
useful for, but I find that using cut makes for less readable code.
\citet{kiselyov05backtracking} is worth reading for alternatives to the
cut statement and the semantics of
\texttt{if}-\texttt{then}-\texttt{else} and \texttt{not} in logic
programming, and Makam follows that paper closely.

\heroNEEDFEEDBACK{}
\todo{Might switch the above to two rules, using a guard clause to differentiate on
the two cases. (I might start using the guards in the later chapters to simplify the presentation
for structural recursion.) How does this look? At this point `P when Q :- R` can be understood to
be entirely equivalent to `P :- Q, R`, however in later chapters this would change -- if the 
`when` clause fails, then the rule is deemed not applicable.}

\begingroup\color{todo}

\begin{verbatim}
eval (case_or_else Scrutinee Pattern Body Else) V'
    when eval Scrutinee V, match Pattern V vnil Subst :-
  vapplymany Body Subst Body', eval Body' V'.
eval (case_or_else Scrutinee Pattern Body Else) V'
    when eval Scrutinee V, not(match Pattern V vnil Subst) :-
  eval Else V'.
\end{verbatim}

\endgroup

\heroSTUDENT{} I see. Now, I noticed a \texttt{vapplymany} predicate -- what
is that?

\heroADVISOR{} That is a standard-library predicate. It is used to perform
simultaneous substitution for all the variables in our multiple binding
type, \texttt{vbindmany}. Or another way to say it, it's the equivalent
of HOAS function application for \texttt{vbindmany}:

\begin{verbatim}
vapplymany : [N] vbindmany Var N Body \ensuremath{\to} vector Var N \ensuremath{\to} Body \ensuremath{\to} prop.
vapplymany (vbody Body) vnil Body.
vapplymany (vbind F) (vcons E ES) Body :- vapplymany (F E) ES Body.
\end{verbatim}

\heroSTUDENT{} I see\ldots{} OK, I think I know how to continue. I will write
a few of the \texttt{match} rules down.

\begin{verbatim}
match patt_var X Subst Subst' :- vsnoc Subst X Subst'.
match patt_wild X Subst Subst.
match patt_ozero ozero Subst Subst.
match (patt_osucc P) (osucc V) Subst Subst' :-
  match P V Subst Subst'.
\end{verbatim}

\begin{scenecomment}
(Our heroes also write down the rules for multiple patterns and tuples, which are
available in the unabridged version of this story.)
\end{scenecomment}

\heroSTUDENT{} Let's try this out with a simple example -- how about
predecessor for natural numbers?

\begin{verbatim}
eval (case_or_else (osucc (osucc ozero))
     (patt_osucc patt_var) (vbind (fun pred \ensuremath{\Rightarrow} vbody pred))
     ozero)
  V ?
>> Yes:
>> V := osucc ozero.
\end{verbatim}

\heroADVISOR{} Looks good! You seem to be getting the hang of this. How about
we do something challenging then? Say, type synonyms?

\heroNEEDFEEDBACK{}
\todo{I have switched to a more incremental presentation here, adding more explanation, since it seems that we lost a few reviewers here last time. However, this makes this section too long; it looks like the centerpiece of the paper, but it shouldn't be. (For example, there's a blog post with a similar encoding from a few years back.) Between this and algebraic datatypes, we will definitely need to cut something in order to have more in-depth explanations, but I'm not sure what. Thoughts? Maybe we should drop the evaluation rule, since it's not introducing anything new other than `if`-`then`-`else` and `appmany`?}

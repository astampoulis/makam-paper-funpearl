\section{In which our heroes are nowhere to be found, lost in a sea of
references to related
work}\label{in-which-our-heroes-are-nowhere-to-be-found-lost-in-a-sea-of-references-to-related-work}

\identNormal

The \textbf{Racket programming language} was designed to support
creation of new programming languages \citep{racket-manifesto} and has
been used to implement a very wide variety of DSLs serving specific
purposes, including typed languages such as Typed Racket by
\citet{typed-racket-main-reference}. We believe that one of the key
characteristics of the Racket approach to language implementation is the
ability to create towers of abstraction through programmatic
manipulation of code. Makam is inspired by this approach to a large
extent and our plan for future work follows similar lines. This is not
demonstrated in the present work, save for the use of
\texttt{refl.assume\_get}, which allows us to treat code (the local
assumptions for a predicate) as reified data (a list of the assumptions
that can be inspected). Still, there are a lot of potential mutual
learnings since the presence of first-class binding support in the form
of higher-order abstract syntax, together with the built-in support for
higher-order unification, makes the \lamprolog
setting significantly different.

The recent development of a method for implementing \textbf{type systems
as macros} by \citet{racket-type-systems-as-macros} is a great
validation of the Racket approach and is especially relevant to our use
case, as it has been used to encode type systems similar to ML. The
integration that this methodology provides with the rest of the Racket
ecosystem offers a number of advantages, as does the
\rulename{Turnstile} DSL for writing typing rules close to the
pen-and-paper versions. We do believe that the higher-order logic
programming setting allows for more expressivity and genericity -- for
example, we have used the same techniques to define not only typing
rules but evaluation rules as well; also, examples such as our MetaML
fragment or Hindley-Milner type inference would not be as easy to
implement in \rulename{Turnstile}, since the latter presently lacks
support for unification. We are exploring an approach similar to
\rulename{Turnstile} to implement a higher-level surface language for
writing typing rules using Makam itself.

Evaluation rules can be implemented using another DSL of the Racket
ecosystem, namely \textbf{PLT Redex} \citep{felleisen2009semantics}, so
a change of framework is required. We believe that staying within the
same framework for both typing and evaluation semantics offers
advantages, especially for encoding languages where the two aspects are
more linked, such as dependently typed languages with the conversion
rule. We give one small example of that in the form of the type synonyms
example. We also find that the presence of first-class substitution
support and the support for structural recursion in Makam offers
advantages over PLT Redex.

The \textbf{Spoofax language workbench} \citep{spoofax-main-reference}
offers a series of DSLs for implementing different aspects of a
language, such as parsing, binding, typing and dynamic semantics. We
have found that some of these DSLs have restrictions that would make the
implementation of type systems similar to the ones we demonstrate in the
present work challenging. Our intention with the design of Makam as a
language prototyping tool is for it to be a single expressive core,
where all different aspects of a language can be implemented. The
\textbf{K Framework} \citep{k-framework-main-reference} is a semantics
framework based on rewriting and has been used to implement the dynamic
semantics of a wide variety of languages. It has also been shown to be
effective for the implementation of type systems
\citep{k-framework-type-systems}, treating them as abstract machines
that compute types rather than values. The recent addition of a builtin
unification procedure has made this approach significantly more
effective, allowing the definition of ML type inference; however, the
fact that \lamprolog supports higher-order unification as well renders
it applicable in further situations such as dependently typed systems.

\textbf{Future work}. We are exploring the addition of a staging
construct to Makam, which allows us to implement extensions to the
language within the language itself, by implementing predicates that
produce new Makam definitions, rules, etc. Examples of this approach are
a library for defining surface syntax for object languages; also, a
language for describing the binding structure of an object language,
alleviating the non-intuitive aspects of some of our encodings. This
approach can also help reduce the reliance on reflective predicates in
some of the examples we show (e.g.~structural recursion), by restricting
the use of reflection within staged code.

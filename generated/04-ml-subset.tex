Let us now proceed to encode more features of a programming language
like ML using the techniques we have seen so far.

First we add polymorphism, therefore extending our simply typed lambda
calculus to System F. We will only consider the explicit polymorphism
case for the time being, leaving type inference for later.

We need a type for quantification over types, as well as term-level
constructs for functions over types and instantiating a polymorphic
function with a specific type.

\begin{verbatim}
forall : (typ \ensuremath{\to} typ) \ensuremath{\to} typ.
lamt : (typ \ensuremath{\to} term) \ensuremath{\to} term.
appt : term \ensuremath{\to} typ \ensuremath{\to} term.
\end{verbatim}

The typing rules are similarly straightforward.

\begin{verbatim}
typeof (lamt E) (forall T) :-
  (a:typ \ensuremath{\to} typeof (E a) (T a)).

typeof (appt E T) (TF T) :-
  typeof E (forall TF).
\end{verbatim}

One thing to note is that in a pen-and-paper version, we would need to
define a new context that keeps track of type variables that are in
scope (typically named \(\Delta\)), and an auxiliary judgement of the
form \(\Delta \vdash \tau \; \text{wf}\) that checks that all type
variables used in \(\tau\) are in scope. Here we get type
well-formedness for free. Furthermore, if we had to keep track of
further information about type variables (e.g.~their kinds), we could
have added an assumption of the form
\texttt{kindof\ a\ K\ \ensuremath{\to}}. Since the local assumption
context can carry rules for any predicate, no extra declaration or
change to the existing rules would be needed, as would be required in
the pen-and-paper version in order to incorporate the new \(\Delta\)
context.

With these additions, we can give a polymorphic type to the identity
function:

\begin{verbatim}
typeof (lamt (fun a \ensuremath{\Rightarrow} lam a (fun x \ensuremath{\Rightarrow} x))) T ?
\end{verbatim}

Moving on towards a more ML-like language, we would like to add the
option to declare algebraic datatypes. We must first introduce a notion
of top-level programs, each composed of a series of declarations of
types and terms, as well as a predicate to check that a program is
well-formed:

\begin{verbatim}
program : type.
wfprogram : program \ensuremath{\to} prop.
\end{verbatim}

Let us add \texttt{let} definitions as a first example of a program
component, each introducing a term variable that can be used in the rest
of the program:

\begin{verbatim}
let : term \ensuremath{\to} (term \ensuremath{\to} program) \ensuremath{\to} program.

wfprogram (let E P) :-
  typeof E T,
  (x:term \ensuremath{\to} typeof x T \ensuremath{\to} wfprogram (P x)).
\end{verbatim}

We also need a ``last'' component for the program, typically a main
expression:

\begin{verbatim}
main : term \ensuremath{\to} program.

wfprogram (main E) :-
  typeof E _.
\end{verbatim}

Let us now proceed to algebraic datatypes. A datatype has a name, a
number of type parameters, and a list of constructors; constructors
themselves have names and lists of arguments:

\begin{verbatim}
typeconstructor : type \ensuremath{\to} type.
constructor : type.

ctor_declaration : type \ensuremath{\to} type.
nil : ctor_declaration unit.
cons : list typ \ensuremath{\to} ctor_declaration T \ensuremath{\to}
         ctor_declaration (constructor * T).
datatype_declaration : type \ensuremath{\to} type \ensuremath{\to} type.
datatype_declaration : 
  (typeconstructor Arity \ensuremath{\to} dbind typ Arity (ctor_declaration Constructors)) \ensuremath{\to}
  datatype_declaration Arity Ctors.

datatype :
  datatype_declaration Arity Constructors \ensuremath{\to}
  (typeconstructor Arity \ensuremath{\to} dbind constructor Constructors program) \ensuremath{\to}
  program.
\end{verbatim}

The datatype introduces a type constructor, as well as a number of
constructors, in the rest of the program. Here we use dependency to
carry the arity of the type constructor in its meta-level type, avoiding
the need for a well-formedness predicate for types. Of course, in
situations where object-level types are more complicated, we would need
to incorporate kind checking into our predicates.

Let us now proceed to well-formedness for datatype declarations. We will
need two auxiliary predicates: one that keeps information about a
constructor -- which type it belongs to, what arguments it expects; and
another one that abstracts over the type variables used in the datatype
declaration, creating a polymorphic type for the type of the
constructor, which can be instantiated with different types at different
places.

\begin{verbatim}
constructor_info :
  typeconstructor Arity \ensuremath{\to} constructor \ensuremath{\to} dbind typ Arity (list typ) \ensuremath{\to} prop.

constructor_polytypes : [Arity Ctors PolyTypes]
  subst typ Arity \ensuremath{\to}
  ctor_declaration Ctors \ensuremath{\to} subst (dbind typ Arity (list typ)) PolyTypes \ensuremath{\to} prop.

constructor_polytypes _ [] [].
constructor_polytypes TypVars (CtorType :: CtorTypes) (PolyType :: PolyTypes) :-
  applymany PolyType TypVars CtorType,
  constructor_polytypes TypVars CtorTypes PolyTypes.
\end{verbatim}

One interesting part intereaction is in the two \texttt{applymany}
calls: these are used in the opposite direction than what we have used
it so far, getting \texttt{TypVars} and \texttt{CtorType} as inputs and
producing \texttt{PolyType} as an output. We need to be careful, though,
to make sure that \texttt{PolyType} cannot capture the \texttt{TypVars}
variables:

\begin{verbatim}
wfprogram (datatype (datatype_declaration ConstructorDecls) Program') :-
  (dt:(typeconstructor T) \ensuremath{\to} ([PolyTypes]
    openmany (ConstructorDecls dt) (pfun tvars constructor_decls \ensuremath{\Rightarrow} (
      constructor_polytypes tvars constructor_decls PolyTypes)),
    openmany (Program' dt) (pfun constructors program' \ensuremath{\Rightarrow}
      assumemany (constructor_info dt) constructors PolyTypes
      (wfprogram program')))).
\end{verbatim}

In order to be able to refer to datatypes and constructors, we will need
type- and term-level formers.

\begin{verbatim}
tconstr : typeconstructor T \ensuremath{\to} subst typ T \ensuremath{\to} typ.
constr : constructor \ensuremath{\to} list term \ensuremath{\to} term.

typeof (constr Constructor Args) (tconstr TypConstr TypArgs) :-
  constructor_info TypConstr Constructor PolyType,
  applymany PolyType TypArgs Typs,
  map typeof Args Typs.
\end{verbatim}

We will also need patterns:

\begin{verbatim}
patt_constr : constructor \ensuremath{\to} pattlist T T' \ensuremath{\to} patt T T'.

typeof (patt_constr Constructor Args) S' S (tconstr TypConstr TypArgs) :-
  constructor_info TypConstr Constructor PolyType,
  applymany PolyType TypArgs Typs,
  typeof Args S' S Typs.
\end{verbatim}

As an example, we will define lists and their append function:

\begin{verbatim}
wfprogram
  (datatype
    (datatype_declaration (fun llist \ensuremath{\Rightarrow} dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (
    [ [] (* nil *) ,
      [a, tconstr llist [a]] (* cons of a * list a *) ]))))
  (fun llist \ensuremath{\Rightarrow} dbindnext (fun lnil \ensuremath{\Rightarrow} dbindnext (fun lcons \ensuremath{\Rightarrow} dbindbase (
  (main
    (letrec
      (dbindnext (fun append \ensuremath{\Rightarrow} dbindbase (
      [ lamt (fun a \ensuremath{\Rightarrow} lam (tconstr llist [a]) (fun l1 \ensuremath{\Rightarrow} lam _ (fun l2 \ensuremath{\Rightarrow}
        case_or_else l1
          (patt_constr lcons [patt_var, patt_var])
            (dbindnext (fun hd \ensuremath{\Rightarrow} dbindnext (fun tl \ensuremath{\Rightarrow} dbindbase (
            constr lcons [hd, app (app (appt append _) tl) l2]))))
          l2))) ])))
      (dbindnext (fun append \ensuremath{\Rightarrow} dbindbase (
    (app (app (appt append _)
      (constr lcons [zero, constr lnil []]))
      (constr lcons [zero, constr lnil []]))
)))))))))) ?
\end{verbatim}

The semantics, if needed:

\begin{verbatim}
patt_to_term (patt_constr Constructor Args) (constr Constructor Args') S' S :-
  pattlist_to_termlist Args Args' S' S.

eval (constr C Args) (constr C Args') :-
  map eval Args Args'.

eval : program \ensuremath{\to} program \ensuremath{\to} prop.

eval (let E P') P'' :-
  eval E V, eval (P' V) P''.

eval (datatype D P') (datatype D P'') :-
  (dt:(typeconstructor T) \ensuremath{\to}
    intromany CS (pfun cs \ensuremath{\Rightarrow} ([P'c P''c]
    applymany (P' dt) cs P'c,
    applymany (P'' dt) cs P''c,
    eval P'c P''c))).

eval (main E) (main V) :-
  eval E V.
\end{verbatim}

Example:

\begin{verbatim}
(eq _PROGRAM (

    (datatype
      (datatype_declaration (fun llist \ensuremath{\Rightarrow} dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (
      [ [] (* nil *) ,
        [a, tconstr llist [a]] (* cons of a * list a *) ]))))
      (fun llist \ensuremath{\Rightarrow} dbindnext (fun lnil \ensuremath{\Rightarrow} dbindnext (fun lcons \ensuremath{\Rightarrow} dbindbase (

    (main (constr lcons [zero, constr lnil []]))

    )))))),

 wfprogram _PROGRAM,
 eval _PROGRAM FINAL) ?
\end{verbatim}

%use "02-stlc".

bindmanyterms : type.
bindnil : term -> bindmanyterms.
bindcons : (term -> bindmanyterms) -> bindmanyterms.

bindmany : type -> type -> type.
bindbase : Body -> bindmany Variable Body.
bindnext : (Variable -> bindmany Variable Body) -> bindmany Variable Body.

lammany : bindmany term term -> term.

applymany : bindmany A B -> list A -> B -> prop.
applymany (bindbase Body) [] Body.
applymany (bindnext F) (HD :: TL) Body :- applymany (F HD) TL Body.

intromany : bindmany A B -> (list A -> prop) -> prop.
intromany (bindbase _) P :- P [].
intromany (bindnext F) P :- (x:A -> intromany (F x) (fun tl => P (x :: tl))).

assumemany : (A -> B -> prop) -> list A -> list B -> prop -> prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y -> assumemany P XS YS Q).

arrowmany : list typ -> typ -> typ.

typeof (lammany F) (arrowmany TS T') :-
  intromany F (pfun xs => ([Body]
    applymany F xs Body, assumemany typeof xs TS (typeof Body T'))).

openmany : bindmany A B -> (list A -> B -> prop) -> prop.
openmany F P :- intromany F (pfun xs => [Body] applymany F xs Body, P xs Body).

typeof (lammany (bindnext (fun x => bindnext (fun y => bindbase (tuple [y, x]))))) T ?
(* >> Yes: *)
(* >> T := arrowmany [T1, T2] (product [T2, T1]) *)

letrec : bindmany term (list term * term) -> term.


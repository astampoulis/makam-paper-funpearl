\section{Where our heroes reflect on structural
recursion}\label{where-our-heroes-reflect-on-structural-recursion}

\heroSTUDENT{} Type synonyms? Difficult? Why? Doesn't this work?

\begin{verbatim}
type_synonym : dbind typ T typ \ensuremath{\to} (typeconstructor T \ensuremath{\to} program) \ensuremath{\to} program.
type_synonym_info : typeconstructor T \ensuremath{\to} dbind typ T typ \ensuremath{\to} prop.

wfprogram (type_synonym Syn Program') :-
  (t:(typeconstructor T) \ensuremath{\to} type_synonym_info t Syn \ensuremath{\to}
    wfprogram (Program' t)).
\end{verbatim}

\heroADVISOR{} Sure, that works. How about the typing rule for them, then?
We'll need something like the conversion rule:

\begin{displaymath}
\inferrule{
  \Gamma \vdash e : \tau \\ \tau =_{\delta} \tau'
}{
  \Gamma \vdash e : \tau'
}
\end{displaymath}

\heroSTUDENT{} Right, \(=_{\delta}\) is equality up to expanding the type
synonyms.

\heroADVISOR{} Yes, we'll definitely need a type-equality predicate.

\begin{verbatim}
teq : typ \ensuremath{\to} typ \ensuremath{\to} prop.
\end{verbatim}

\heroSTUDENT{} OK. And then we do this?

\begin{verbatim}
typeof E T :- typeof E T', teq T T'.
\end{verbatim}

\heroADVISOR{} That would be nice, but we'll go into an infinite loop if that
rule gets used.

\heroSTUDENT{} Oh. Oh, right. There is a specific proof-finding strategy in
logic programming, it can't always work\ldots{} I guess we have to
switch our rules to an algorithmic type system instead.

\heroADVISOR{} Precisely. Well, luckily, we can do that to a certain extent,
without rewriting everything. Consider this: we only need to use the
conversion rule in cases where we already know something about the type
\texttt{T} of the expression, but our typing rules do not match that
type.

\heroSTUDENT{} Oh. Do you mean that in bi-directional typing terms? So, doing
type analysis of an expression with a concrete type \texttt{T} might
fail, but synthesizing the type anew could work?

\heroADVISOR{} Exactly, and in that case we have to check that the two types
are equal, using \texttt{teq}. So we need to change the rule you wrote
to apply only in the case where \texttt{T} starts with a concrete
constructor, rather than when it is an uninstantiated unification
variable.

\heroSTUDENT{} Is that even possible? Is there a way in \foreignlanguage{greek}{λ}Prolog to tell
whether something is a unification variable?

\heroADVISOR{} There is! Most Prolog dialects have a predicate that does that
-- it's usually called \texttt{var}. In Makam this is called
\texttt{refl.isunif}, the \texttt{refl} namespace prefix standing for
\emph{reflective} predicates. So a second attempt would be this:

\begin{verbatim}
typeof E T :- not(refl.isunif T), typeof E T', teq T T'.
\end{verbatim}

\heroSTUDENT{} Interesting. But wouldn't this lead to an infinite loop too?
After all, \texttt{teq} is reflexive -- so we could end up in the same
situation as before.

\heroADVISOR{} Correct: for every proof of
\texttt{typeof\ E\ T\textquotesingle{}} through the other rules, a new
proof using this rule will be discovered, which will lead to another
proof for it, etc. One fix is to make sure that this rule is only used
once at the end, if typing using the normal rules fails.

\heroSTUDENT{} So, something like this:

\begin{verbatim}
typeof, typeof_cases, typeof_conversion : term \ensuremath{\to} typ \ensuremath{\to} prop.
typeof E T :-
  if (typeof_cases E T) then success else (typeof_conversion E T).
typeof_cases (app E1 E2) T' :- typeof E1 (arrow T1 T2), typeof E2 T1.
...
typeof_conversion E T :- not(refl.isunif T), typeof_cases E T', teq T T'.
\end{verbatim}

\heroADVISOR{} Yes, but let's do a trick to side-step the issue for now. We
will force the rule to only fire once for each expression \texttt{E}, by
remembering that we have used the rule already:

\begin{verbatim}
already_in : [A] A \ensuremath{\to} prop.
typeof E T :- not(refl.isunif T), not(already_in (typeof E)),
              (already_in (typeof E) \ensuremath{\to} typeof E T'), teq T T'.
\end{verbatim}

\heroSTUDENT{} If we ever made a paper submission out of this, the reviewers
would not be happy about this rule. But sure. We still need to define
\texttt{teq} now. Oh, and we should add the conversion rule for
patterns, but that's almost identical as for terms. (\ldots{}) I'll do
\texttt{teq}\ldots{}

\begin{verbatim}
teq (tconstr TC Args) T' :- type_synonym_info TC Syn, applymany Syn Args T, teq T T'.
teq T' (tconstr TC Args) :- type_synonym_info TC Syn, applymany Syn Args T, teq T' T.
teq (arrow T1 T2) (arrow T1' T2') :- teq T1 T1', teq T2 T2'.
teq (product TS) (product TS') :- map teq TS TS'.
...
\end{verbatim}

\heroADVISOR{} Writing boilerplate is not fun, is it?

\heroSTUDENT{} It is not. I wish we could just write the first two rules; they
are the important ones after all. All the other ones just propagate the
structural recursion through. Also, whenever we add a new constructor
for types, we'll have to remember to add a \texttt{teq} rule for
it\ldots{}.

\heroADVISOR{} Let us reflect a little bit on that.

\TODO{} From here on.

Only the two last cases are important; the rest is boilerplate that
performs structural recursion through the type. Can we do better than
that?

Let us ruminate on a possible solution. We want to handle the case where
we have a constructor applied to a number of arguments generically, so
roughly something like:

\begin{verbatim}
teq (Constructor Arguments) (Constructor Arguments') :-
  map teq Arguments Arguments'.
\end{verbatim}

What we mean here, taking the \texttt{arrow} rule as an example, is that
\texttt{Constructor} would match with \texttt{arrow}, and
\texttt{Arguments} would get instantiated with the list of arguments of
the constructor. One thing to be careful about, though, is that the
types of arguments are not all the same. As a result, instead of a
homogeneous list, we need a heterogeneous list, which is simple to
represent using the existential type, \texttt{dyn}:

\begin{verbatim}
dyn : type.
dyn : A \ensuremath{\to} dyn.
\end{verbatim}

So the type of \texttt{Arguments} should be \texttt{list\ dyn} rather
than \texttt{list\ typ}. The type of \texttt{teq} will need to be
changed, so that we can apply it for any different type, rather than
just \texttt{typ}:

\begin{verbatim}
teq : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
\end{verbatim}

Furthermore, since we have a heterogeneous list, we need a \texttt{map}
that uses polymorphic recursion: it needs take a polymorphic function as
an argument, so that it can be used at different types for different
elements of the list.

\begin{verbatim}
dyn.map : (forall A. [A] A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} list dyn \ensuremath{\to} list dyn \ensuremath{\to} prop.
\end{verbatim}

This type is in contrast to one like
\texttt{{[}A{]}\ (A\ \ensuremath{\to}\ A\ \ensuremath{\to}\ prop)\ \ensuremath{\to}\ list\ dyn\ \ensuremath{\to}\ list\ dyn\ \ensuremath{\to}\ prop},
which would instantiate the type \texttt{A} to the type of the first
element of the list, making further applications to different types
impossible.

Makam currently does not provide higher-rank types as the above type
suggests -- nor do any \foreignlanguage{greek}{λ}Prolog implementations that we are aware of.
Instead, it provides a way to side-step this issue, through a predicate
that replaces polymorphic type variables with fresh variables, allowing
it to be instantiated with new types. This is called \texttt{dyn.call},
and \texttt{dyn.map} can be defined in terms of it:

\begin{verbatim}
dyn.call : [B] (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.
dyn.map : (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} list dyn \ensuremath{\to} list dyn \ensuremath{\to} prop.
dyn.map P [] [].
dyn.map P (HD :: TL) (HD' :: TL') :- dyn.call P HD HD', dyn.map P TL TL'.
\end{verbatim}

(\texttt{dyn.call} is itself defined in terms of a more fundamental
predicate \texttt{dyn.duphead} that creates a fresh version of a single
polymorphic constructor with fresh type variables.)

Based on these, the only thing missing is a way to actually check
whether a term is a ground term that can be decomposed into a
constructor and a list of arguments. Makam provides that functionality
in the form of the \texttt{refl.headargs} predicate:

\begin{verbatim}
refl.headargs : B \ensuremath{\to} A \ensuremath{\to} list dyn \ensuremath{\to} prop.
\end{verbatim}

(Other Prolog implementations also provide predicates towards the same
effect; for example, SWI-Prolog provides
\texttt{compound\_name\_arguments}, which is quite similar. Though such
predicates are not typical in other \foreignlanguage{greek}{λ}Prolog implementations, they should
not be viewed as a hack: we could always define these within the
language if we maintained a discipline, where we added a rule to
\texttt{refl.headargs} for every constructor that we introduce. For
example:

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.
refl.headargs (arrowmany TS T) [arrowmany, [dyn TS, dyn T]].
\end{verbatim}

The only other wrinkle would be to check via \texttt{refl.isunif} that
we are not instantiating a unification variable.)

We are now ready to proceed to defining the boilerplate generically. We
will do this as a reusable higher-order predicate for structural
recursion, which we will use to implement \texttt{teq}. We will define
it in open-recursion style, providing the predicate to use on recursive
calls as an argument:

\begin{verbatim}
structural_recursion : [B] (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.

structural_recursion Rec X Y :-
  refl.headargs X Constructor Arguments,
  dyn.map Rec Arguments Arguments',
  refl.headargs Y Constructor Arguments'.
\end{verbatim}

We also need to handle built-in types, such as the meta-level
\texttt{int} and \texttt{string} types, in case they are used as
arguments with other constructors:

\begin{verbatim}
structural_recursion Rec (X : string) (X : string).
structural_recursion Rec (X : int) (X : int).
\end{verbatim}

And last, we need to handle the case of the meta-level function type as
well:

\begin{verbatim}
structural_recursion Rec (X : A \ensuremath{\to} B) (Y : A \ensuremath{\to} B) :-
  (x:A \ensuremath{\to} structural_recursion Rec x x \ensuremath{\to} structural_recursion Rec (X x) (Y x)).
\end{verbatim}

We are done! Now we can define \texttt{teq} using
\texttt{structural\_recursion}, through an auxiliary predicate called
\texttt{teq\_aux}. We only need to define the non-trivial cases for it,
using \texttt{structural\_recursion} for the rest, while tying the open
recursion knot at the same time:

\begin{verbatim}
teq_aux : [A] A \ensuremath{\to} A \ensuremath{\to} prop.

teq T T' :- teq_aux T T'.

teq_aux T T' :-
  structural_recursion teq_aux T T'.

teq_aux (tconstr TC Args) T' :-
  type_synonym_info TC Synonym,
  applymany Synonym Args T,
  teq_aux T T'.

teq_aux T' (tconstr TC Args) :-
  type_synonym_info TC Synonym,
  applymany Synonym Args T,
  teq_aux T' T.
\end{verbatim}

Other than minimizing the boilerplate, the great thing about using
\texttt{structural\_recursion} is that no adaptation needs to be done
when we add any new constructor to our \texttt{typ} datatype -- even if
it uses new types that we have not defined before. For example, we did
not have to take any special provision to handle types we defined
earlier such as \texttt{dbind} -- everything works out thanks to the
reflective predicates we are using. (Mention something about the
expression problem?)

The one form of terms that \texttt{structural\_recursion} does not
handle are uninstantiated unification variables. We have found that it
works well to define special handling of unification variables for each
new generically recursive predicate. In this case, \texttt{teq} is only
supposed to be used with ground terms, so it is fine if we fail when we
encounter a unification variable.

Let us try out an example:

\begin{verbatim}
ascribe : term \ensuremath{\to} typ \ensuremath{\to} term.
typeof (ascribe E T) T :- typeof E T.

wfprogram (
  (type_synonym (dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (product [a, a])))
  (fun bintuple \ensuremath{\Rightarrow} 
  
  main (lam (tconstr bintuple [product [nat, nat]])
            (fun x \ensuremath{\Rightarrow} 
    case_or_else x
    (patt_tuple [patt_tuple [patt_wild, patt_wild], patt_tuple [patt_wild, patt_wild]])
    (dbindbase (tuple []))
    (tuple [])
  ))
))) ?
>> Yes.
\end{verbatim}

Let us make sure we do not diverge on type error:

\begin{verbatim}
wfprogram (
  (type_synonym (dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (product [a, a])))
  (fun bintuple \ensuremath{\Rightarrow} 
  
  main (lam (tconstr bintuple [product [nat, nat]])
            (fun x \ensuremath{\Rightarrow} 
    case_or_else x
    (patt_tuple [patt_tuple [patt_wild], patt_tuple [patt_wild, patt_wild]])
    (dbindbase (tuple []))
    (tuple [])
  ))
))) ?
>> Impossible.
\end{verbatim}

As we've seen, single-variable binding as in the lambda abstraction can
be handled easily through higher-order abstract syntax. Let us now
explore how to encode other forms of binding.

As a first example, we will introduce multiple-argument functions as a
distinct object-level construct, as opposed to using currying. A first
attempt at encoding such a construct could be to introduce a
\texttt{list} of term variables at the same time, as follows:

\begin{verbatim}
lammany : (list term \ensuremath{\to} term) \ensuremath{\to} term.
\end{verbatim}

However, this type does not correspond to the construct we are trying to
encode. The type \texttt{list\ term\ \ensuremath{\to}\ term} introduces a
fresh local variable for the \texttt{list} type, as opposed to a number
of fresh local variables for the \texttt{term} type. Since the HOAS
function space is parametric, there is no way to even refer to the
potential elements of the fresh \texttt{list} -- we can only refer to
the fresh list in full.

Instead, we would like a type that represents all types of the form:

\begin{itemize}
\tightlist
\item
  \texttt{term} (binding no variables)
\item
  \texttt{term\ \ensuremath{\to}\ term} (binding a single variable)
\item
  \texttt{term\ \ensuremath{\to}\ (term\ \ensuremath{\to}\ term)} (binding
  two variables)
\item
  \texttt{term\ \ensuremath{\to}\ (term\ \ensuremath{\to}\ (term\ \ensuremath{\to}\ term))}
  (binding three variables) etc.
\end{itemize}

We can encode such a type inductively in \ensuremath{\lambda}Prolog, as follows:

\begin{verbatim}
bindmanyterms : type.
bindbase : term \ensuremath{\to} bindmanyterms.
bindnext : (term \ensuremath{\to} bindmanyterms) \ensuremath{\to} bindmanyterms.
\end{verbatim}

Furthermore, we can generalize the type that we are binding over, and
the type of the body, leading to a polymorphic type of the form:

\begin{verbatim}
bindmany : type \ensuremath{\to} type \ensuremath{\to} type.
bindbase : B \ensuremath{\to} bindmany A B.
bindnext : (A \ensuremath{\to} bindmany A B) \ensuremath{\to} bindmany A B.
\end{verbatim}

With these, \texttt{lammany} can be encoded as:

\begin{verbatim}
lammany : bindmany term term \ensuremath{\to} term.
\end{verbatim}

(As an aside: here we have allowed binding zero variables for
presentation reasons. We could disallow binding zero variables by
changing the \texttt{base} case to require an argument of type
\texttt{A\ \ensuremath{\to}\ B} instead of a \texttt{B}, similar to how
we can specify lists with at least one element inductively by replacing
the \texttt{nil} constructor with a constructor that requires an
element.)

How do we work with the \texttt{bindmany} type? For the built-in single
binding type, we used three operations:

\begin{itemize}
\tightlist
\item
  variable substitution, encoded through HOAS function application
\item
  introducing a fresh variable, through the predicate form
  \texttt{x:term\ \ensuremath{\to}\ ...}
\item
  introducing a new assumption, through the predicate form
  \texttt{P\ \ensuremath{\to}\ ...}
\end{itemize}

We can define three equivalent operations as predicates, for the
multiple binding case:

-- \emph{a generalization of application}, for substituting all the
variables in a \texttt{bindmany}

\begin{verbatim}
applymany : bindmany A B \ensuremath{\to} list A \ensuremath{\to} B \ensuremath{\to} prop.
applymany (bindbase Body) [] Body.
applymany (bindnext F) (HD :: TL) Body :-
  applymany (F HD) TL Body.
\end{verbatim}

-- \emph{local introduction of multiple fresh variables at once} within
a predicate P; a list of the variables is passed to it

\begin{verbatim}
intromany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} prop) \ensuremath{\to} prop.
intromany (bindbase _) P :- P [].
intromany (bindnext F) P :-
  (x:A \ensuremath{\to} intromany (F x) (fun tl \ensuremath{\Rightarrow} P (x :: tl))).
\end{verbatim}

-- \emph{local introduction of a number of assumptions} of the form
\texttt{P\ X\ Y} within a predicate \texttt{Q}.

This is intended to be used, for example, for introducing assumptions
for predicates such as \texttt{typeof}, taking a list of term variables
and a list of types, in the same order.

\begin{verbatim}
assumemany : (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} list A \ensuremath{\to} list B \ensuremath{\to} prop \ensuremath{\to} prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y \ensuremath{\to} assumemany P XS YS Q).
\end{verbatim}

These predicates are in exact correspondence with the operations we have
available for the built-in HOAS function type -- save for application
being a predicate rather than a term-level construct -- so we are able
to reap the benefits of HOAS representations for multiple bindings as
well.

For convenience, it is also useful to define another predicate that
gives access to both the variables introduced in a \texttt{bindmany} and
the body of the construct as well. This predicate combines
\texttt{intromany}, for introducing the variables, with
\texttt{applymany}, for getting the body of the construct, and is
defined as follows:

\begin{verbatim}
openmany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
openmany F P :-
  intromany F (pfun xs \ensuremath{\Rightarrow} [Body] applymany F xs Body, P xs Body).
\end{verbatim}

Two notational idiosyncrasies here of Makam, the \ensuremath{\lambda}Prolog dialect we are
using:

\texttt{pfun} is syntactic convenience for anonymous predicate literals,
allowing to use the normal syntax for propositions that we use
elsewhere, i.e.~in clause premises. It is otherwise entirely equivalent
to the \texttt{fun} construct for anonymous functions.

The square bracket notation, used above in \texttt{{[}Body{]}},
introduces a new metavariable; it therefore can be read as existential
quantification. Metavariables are allowed to capture all the free
variables in scope at the point where they are introduced. For most of
them, introduced implicitly in each clause, this means the free
variables in scope when the clause is used. In this case however it is
necessary that \texttt{Body} can capture the fresh variables introduced
by the \texttt{intromany} predicate too, hence the explicit metavariable
introduction.

We can now define the typing rule for \texttt{lammany} using these
predicates, as follows:

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.

typeof (lammany F) (arrowmany TS T') :-
  openmany F (fun xs body \ensuremath{\Rightarrow}
    assumemany typeof xs TS (typeof body T')).
\end{verbatim}

For example, the following query returns:

\begin{verbatim}
typeof (lammany (bindnext (fun x \ensuremath{\Rightarrow} bindnext (fun y \ensuremath{\Rightarrow} bindbase (tuple [x, y]))))) T ?
>> Yes:
>> T := arrowmany [T1, T2] (product [T1, T2])
\end{verbatim}

Adding the corresponding \texttt{appmany} construct for simultaneous
application is straightforward. We can use the \texttt{applymany}
predicate defined above to encode simultaneous substitution for the
evaluation rule.

\begin{verbatim}
appmany : term \ensuremath{\to} list term \ensuremath{\to} term.

typeof (appmany E ES) T' :-
  typeof E (arrowmany TS T'),
  map typeof ES TS.

eval (lammany F) (lammany F).

eval (appmany E ES) V' :-
  eval E (lammany F),
  map eval ES VS,
  applymany F VS E',
  eval E' V'.
\end{verbatim}

We can use the \texttt{bindmany} type to encode other constructs, such
as mutually recursive definitions, like the \texttt{let\ rec} construct
of ML. In that case, we can capture the right binding structure by
introducing a number of variables simultaneously, accessible both when
giving the (same number of) definitions and the body of the construct.

We can therefore encode a \texttt{let\ rec} construct of the form:

\begin{verbatim}
let rec f = f_def and g = g_def in body
\end{verbatim}

as

\begin{verbatim}
letrec (bindnext (fun f \ensuremath{\Rightarrow} bindnext (fun g \ensuremath{\Rightarrow} bindbase ([f_def, g_def]))))
       (bindnext (fun f \ensuremath{\Rightarrow} bindnext (fun g \ensuremath{\Rightarrow} bindbase body)))
\end{verbatim}

The type-checking rule would be as follows:

\begin{verbatim}
letrec : bindmany term (list term) \ensuremath{\to} bindmany term term \ensuremath{\to} term.

typeof (letrec XS_Defs XS_Body) T' :-
  openmany XS_Defs (pfun xs defs \ensuremath{\Rightarrow}
    assumemany typeof xs TS (map typeof defs TS)
  ),
  openmany XS_Body (pfun xs body \ensuremath{\Rightarrow}
    assumemany typeof xs TS (typeof body T')
  ).
\end{verbatim}

Still, even though this encoding matches the binding structure
correctly, it is unsatisfying, as it does not guarantee that the same
number of variables are introduced in both cases and that the same
number of definitions are given. Though this requirement is enforced at
the level of the typing rules, it would be better if we could enforce it
at the syntax level. This would require some sort of dependency though,
which at first does not seem possible to do in \ensuremath{\lambda}Prolog.

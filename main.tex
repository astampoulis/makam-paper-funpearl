\documentclass[format=acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{alltt}
\usepackage{xspace}

\bibliographystyle{shared/ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


\begin{document}

\title{Makam}
\subtitle{Functional Pearl}

\author{Antonis Stampoulis}
\affiliation{
  \institution{Originate Inc.}
  \city{New York}
  \state{New York}
}
\email{antonis.stampoulis@gmail.com}

\author{Adam Chlipala}
\affiliation{
  \department{CSAIL}
  \institution{MIT}
  \city{Cambridge}
  \state{Massachusetts}
}
\email{adamc@csail.mit.edu}

\newcommand\TODO[0]{\textbf{TODO}}
\newcommand\lamprolog[0]{$\lambda$Prolog\xspace}

\begin{abstract}
\TODO{} This is the abstract of the paper.
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%% \begin{CCSXML}
%% <ccs2012>
%% <concept>
%% <concept_id>10011007.10011006.10011008</concept_id>
%% <concept_desc>Software and its engineering~General programming languages</concept_desc>
%% <concept_significance>500</concept_significance>
%% </concept>
%% <concept>
%% <concept_id>10003456.10003457.10003521.10003525</concept_id>
%% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
%% <concept_significance>300</concept_significance>
%% </concept>
%% </ccs2012>
%% \end{CCSXML}

%% \ccsdesc[500]{Software and its engineering~General programming languages}
%% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\maketitle


%% === Introduction

\section{Introduction}

\TODO{} This is the introduction. We will cite the work by \citet{miller1988overview} here.

% === Simple functional language

\section{Starting out simple}

We will start by encoding a version of the simply typed lambda calculus in \lamprolog. We define two
new meta-types to represent the two sorts of our object language: terms and types. We also define
the \texttt{typeof} relation that corresponds to the typing judgement of the language.

\begin{alltt}
term   : type.
typ    : type.
typeof : term -> typ -> prop.
\end{alltt}

Defining the basic forms of the lambda calculus is easy, thanks to the support of higher-order
abstract syntax in higher-order logic programming. We can reuse the meta-level function type in
order to implement object-level binding. This is because the meta-level function space is
\textit{parametric} -- that is, the body of a function is a value that can just mention the argument
as-is, instead of being a computation that can inspect the specific value of an argument. Therefore,
meta-level functions exactly represent an object-level binding of a single variable, without
introducing \textit{exotic terms}.

\begin{alltt}
app    : term -> term -> term.
lam    : typ -> (term -> term) -> term.
arrow  : typ -> typ -> typ.
\end{alltt}

Encoding the typing rule for application as a \lamprolog \textit{clause} for the \texttt{typeof} relation is a
straightforward transliteration of the pen-and-paper version.

\begin{alltt}
typeof (app E1 E2) T' :-
  typeof E1 (arrow T T'),
  typeof E2 T.
\end{alltt}

In logic programming, the goal of a rule is written first, followed by the premises; the \texttt{:-}
operator can be read as "is implied by," and comma is logical conjuction. We use capital letters for
unification variables.

The rule for lambda functions is similarly straightforward: 

\begin{alltt}
typeof (lam T1 E) (arrow T1 T2) :-
  (x:term -> typeof x T1 -> typeof (E x) T2).
\end{alltt}

There are three things of note in the premise of the rule. First, we introduce a fresh term variable
\texttt{x}, through the form \texttt{x:term ->}, which can be read as universal quantification. Second, we
introduce a new assumption through the form \texttt{typeof x T ->}, which essentially introduces a new rule
for the \texttt{typeof} relation locally; this can be read as logical implication. Third, in order to get
to the body of the lambda function to type-check it, we need to apply it to the fresh variable \texttt{x}.

With these definitions, we have already implemented a type-checker for the simply typed lambda
calculus, as we can issue queries for the \texttt{typeof} relation to Makam:

\begin{alltt}
typeof (lam _ (fun x => x)) T' ?
>> Yes:
>> T' := arrow T T
\end{alltt}

One benefit of using \lamprolog instead of rolling our own type-checker is that the occurs check is
already implemented in the unification engine. As a result, a query that would result in an
ill-formed cyclical type with a naive implementation of unification fails as expected.

\begin{alltt}
typeof (lam _ (fun x => app x x)) T' ?
>> Impossible.
\end{alltt}

Other than supporting higher-order abstract syntax, \lamprolog also supports polymorphic types and
higher-order predicates, in a matter akin to traditional functional programming languages. For
example, we can define the polymorphic \texttt{list} type, and an accompanying \texttt{map}
higher-order predicate, as follows:

\begin{alltt}
list : type -> type.

nil : list A.
cons : A -> list A -> list A.

map : (A -> B -> prop) -> list A -> list B -> prop.
map P nil nil.
map P (cons X XS) (cons Y YS) :- P X Y, map P XS YS.
\end{alltt}

Using the meta-level \texttt{list} type, we can encode object-level constructs such as tuples and product
types directly:

\begin{alltt}
tuple : list term -> term.
product : list typ -> typ.
\end{alltt}

Similarly we can use the \texttt{map} predicate to define the typing relation for tuples. 

\begin{alltt}
typeof (tuple ES) (product TS) :-
  map typeof ES TS.
\end{alltt}

Executing a query with a tuple yields the right result:

\begin{alltt}
typeof (lam _ (fun x => lam _ (fun y => tuple (cons x (cons y nil))))) T ?
>> Yes:
>> T := arrow T1 (arrow T2 (product (cons T1 (cons T2 nil))))
\end{alltt}

So far we have only introduced the predicate \texttt{typeof} for typing. In the same way, we can introduce
a predicate for evaluating terms, capturing the dynamic semantics of the language.

\begin{alltt}
eval : term -> term -> prop.
\end{alltt}

Most of the rules are straightforward, following standard practice for big-step semantics.  We
assume a call-by-value evaluation strategy.

\begin{alltt}
eval (lam T F) (lam T F).
eval (tuple ES) (tuple VS) :- map eval ES VS.
\end{alltt}

For the beta-redex case, function application for higher-order abstract syntax gives us
capture-avoiding substitution directly:

\begin{alltt}
eval (app E E') V'' :-
  eval E (lam _ F), eval E' V', eval (F V') V''.
\end{alltt}

%% === Conclusion

\section{Conclusion}

\TODO{} We conclude the paper.

\bibliography{main}

\end{document}

(Text is very much WIP.)

Next we extend with Hindley-Milner let-polymorphism:

\begin{verbatim}
let : term \ensuremath{\to} (term \ensuremath{\to} term) \ensuremath{\to} term.
\end{verbatim}

The inference rule looks like this:

\begin{displaymath}
\inferrule{
  \Gamma \vdash e : \tau \\
  \vec{a} = \text{fv}(\tau) - \text{fv}(\Gamma) \\
  \Gamma, x : \forall \vec{a}.\tau \vdash e' : \tau'
}{
  \Gamma \vdash \text{let} \; x = e \; \text{in} \; e' : \tau'
}
\end{displaymath}

(We have not added any side-effectful operations, so no need to add a
value restriction.)

The rule is easy to transcribe in Makam, assuming a predicate for
generalizing a type:

\begin{verbatim}
generalize : typ \ensuremath{\to} typ \ensuremath{\to} prop.

typeof (let E F) T' :-
  typeof E T,
  generalize T Tgen,
  (x:term \ensuremath{\to} typeof x Tgen \ensuremath{\to} typeof (F x) T').
\end{verbatim}

So we need the following ingredients:

\begin{itemize}
\tightlist
\item
  something that picks out free variables from a term -- or, in our
  setting, uninstantiated meta-variables
\item
  something that picks out free variables from the local context
\item
  a way to turn something that includes meta-variables into a
  \texttt{forall} type
\end{itemize}

This predicate picks out the first metavariable of a certain type it
finds. It uses \texttt{generic.fold}, which is another generic
operation, defined similarly to \texttt{structural\_recursion}, but
which performs a fold over arbitrary types.

\begin{verbatim}
findunif : [A B] option B \ensuremath{\to} A \ensuremath{\to} option B \ensuremath{\to} prop.
findunif (some X) _ (some X).
findunif none (X : A) (some (X : A)) :- refl.isunif X.
findunif In X Out :- generic.fold findunif In X Out.

findunif : [A B] A \ensuremath{\to} B \ensuremath{\to} prop.
findunif T X :- findunif none T (some X).
\end{verbatim}

Note that the second rule, the important one, will only match when we
encounter a metavariable of the same type as the one we require, as we
do type specialization.

Now we add an operation that, given a specific meta-variable and a
specific term, replaces the meta-variable with the term. We will see
later why this operation is necessary. Here we will need another
reflective predicate, \texttt{refl.sameunif}, that succeeds when its two
arguments are the same exact metavariable, to avoid the undesired side
effect of unifying distinct metavariables.

\begin{verbatim}
replaceunif : [A B] A \ensuremath{\to} A \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.
replaceunif Which ToWhat Where Result :-
  refl.isunif Where,
  if (refl.sameunif Which Where)
  then (eq (dyn Result) (dyn ToWhat))
  else (eq Result Where).
replaceunif Which ToWhat Where Result :-
  not(refl.isunif Where),
  structural_recursion (replaceunif Which ToWhat) Where Result.
\end{verbatim}

A last auxiliary predicate will allow us to check whether a specific
metavariable exists within a term:

\begin{verbatim}
hasunif : [A B] B \ensuremath{\to} bool \ensuremath{\to} A \ensuremath{\to} bool \ensuremath{\to} prop.
hasunif _ true _ true.
hasunif X false Y true :- refl.sameunif X Y.
hasunif X In Y Out :- generic.fold (hasunif X) In Y Out.

hasunif : [A B] A \ensuremath{\to} B \ensuremath{\to} prop.
hasunif Term Var :- hasunif Var false Term true.
\end{verbatim}

We are now ready to implement \texttt{generalize}. Base case: there
exist no unification variables within a type:

\begin{verbatim}
generalize T T :- 
  not(findunif T X).
\end{verbatim}

Recursive case: there exists at least one unification variable. We will
pick out that unification variable, abstract over it, and repeat the
process to pick out any remaining ones. We will check whether we are
allowed to generalize by computing a summary of all \texttt{typ}s in the
current variable environment -- that is, all \texttt{T}s for any
\texttt{typeof\ x\ T} local assumptions -- and making sure that the
current unification variable does not occur in that. Getting the types
in the environment is done through the
\texttt{get\_types\_in\_environment} predicate, and we will leave the
type of its result abstract for the time being.

\begin{verbatim}
get_types_in_environment : [A] A \ensuremath{\to} prop.

generalize T Res :-
  findunif T X,
  (x:typ \ensuremath{\to} (replaceunif X x T (T' x), generalize (T' x) (T'' x))),
  get_types_in_environment Types,
  if (hasunif Types X)
  then (eq Res (T'' X))
  else (eq Res (forall T'')).
\end{verbatim}

What can \texttt{get\_types\_in\_environment} be? We could change all
our typing rules to add a list argument that holds all the types that we
put in the context, threading it through all our predicates. However,
again using reflective predicates, there is an easier way to do that: we
can simply get all the local assumptions for the \texttt{typeof}
predicate for terms, which will exactly correspond to the local
assumptions for the current set of free variables:

\begin{verbatim}
get_types_in_environment Assumptions :-
  refl.assume_get (typeof : term \ensuremath{\to} typ \ensuremath{\to} prop) Assumptions.
\end{verbatim}

That is the end of our extension to Hindley-Milner inference, and here
is a first easy example query.

\begin{verbatim}
typeof (let (lam _ (fun x \ensuremath{\Rightarrow} x)) (fun id \ensuremath{\Rightarrow} id)) T ?
>> Yes:
>> T := forall (fun a \ensuremath{\Rightarrow} arrow a a)
\end{verbatim}

Another example, where the problem of naive generalization shows up:

\begin{verbatim}
typeof (let (lam _ (fun x \ensuremath{\Rightarrow} let x (fun y \ensuremath{\Rightarrow} y)))
            (fun z \ensuremath{\Rightarrow} z)) T ?
>> Yes:
>> T := forall (fun a \ensuremath{\Rightarrow} arrow a a)
\end{verbatim}

(Just checking the issue where we don't remove all unification variables
in the context -- this is a hack, if we need to do this we can show the
above in two steps instead:)

\begin{verbatim}
(get_types_in_environment [] \ensuremath{\to}
  typeof (let (lam _ (fun x \ensuremath{\Rightarrow} let x (fun y \ensuremath{\Rightarrow} y)))
            (fun z \ensuremath{\Rightarrow} z)) T) ?
>> Yes:
>> T := forall (fun a \ensuremath{\Rightarrow} arrow a (forall (fun b \ensuremath{\Rightarrow} b)))
\end{verbatim}

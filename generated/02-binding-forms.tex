\section{Where our heroes add parentheses and discover how to do
multiple
binding}\label{where-our-heroes-add-parentheses-and-discover-how-to-do-multiple-binding}

\heroSTUDENT{} Still, I feel like we've been playing to the strengths of
\foreignlanguage{greek}{位}Prolog\ldots{}. Yes, single-variable binding, substitutions, and so on
work nicely, but how about any other form of binding? Say, binding
multiple variables at the same time? We are definitely going to need
that for the language we have in mind, and I remember that
\citet{keuchel2016needle} mention that HOAS encodings do not work for
such forms of binding.

\heroADVISOR{} I beg to differ. Let's try it out; let's try adding
multiple-argument functions for example -- I mean uncurried ones. Want
to give it at try?

\heroSTUDENT{} Let me see. Well, I want to write something like this, but I
know this is wrong.

\begin{verbatim}
lammany : (list term \ensuremath{\to} term) \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} Yes, that doesn't quite work. It would introduce a fresh
variable for \texttt{list}s, not a number of fresh variables for
\texttt{term}s. HOAS functions are parametric, too, which means we
cannot even get to the potential elements of the fresh \texttt{list}
inside the \texttt{term}.

\heroSTUDENT{} Right. So I don't know, instead we want to use a type that
stands for \texttt{term\ \ensuremath{\to}\ term},
\texttt{term\ \ensuremath{\to}\ term\ \ensuremath{\to}\ term}, and so on.
Can we write \texttt{term\ \ensuremath{\to}\ ...\ \ensuremath{\to}\ term}?

\heroADVISOR{} Well, not quite, but we have already defined something similar,
a type that roughly stands for \texttt{term\ *\ ...\ *\ term}, and we
did not need anything special for that\ldots{}

\heroSTUDENT{} You mean the \texttt{list} type?

\heroADVISOR{} Exactly. What do you think about this definition?

\begin{verbatim}
bindmanyterms : type.
bindnil : term \ensuremath{\to} bindmanyterms.
bindcons : (term \ensuremath{\to} bindmanyterms) \ensuremath{\to} bindmanyterms.
\end{verbatim}

\heroSTUDENT{} Hmm. That looks quite similar to lists; the parentheses in
\texttt{cons} are different. \texttt{nil} gets an extra \texttt{term}
argument, too\ldots{}.

\heroADVISOR{} Yes\ldots{} So what is happening here is that \texttt{bindcons}
takes a single argument, adding another binder; and \texttt{bindnil} is
when we get to the body and don't need any more binders, so we just need
the body.

\heroSTUDENT{} Oh, so could we generalize their types? Maybe that will help me
get a better grasp of it. How is this?

\begin{verbatim}
bindmany : type \ensuremath{\to} type \ensuremath{\to} type.
bindbase : Body \ensuremath{\to} bindmany Variable Body.
bindnext : (Variable \ensuremath{\to} bindmany Variable Body) \ensuremath{\to} bindmany Variable Body.
\end{verbatim}

\heroADVISOR{} This looks great! Though let me say, I cheated a bit: in order
for the constructors to look nicer, we have allowed binding zero
variables. We could definitely disallow that by changing
\texttt{bindbase} to take a \texttt{Variable\ \ensuremath{\to}\ Body}
argument instead, but let's just go along with this; it will make all
our predicates simpler to write, too.

\heroSTUDENT{} I see. That is quite an interesting datatype. Is there some
reference about it?

\heroADVISOR{} Not that I know of -- though I think this is part of PL
folklore. After I started using this in Makam, I noticed similar
constructions in the wild, for example in MTac \citep{ziliani2013mtac},
for the parametric HOAS implementation of telescopes.

\heroSTUDENT{} Interesting. So how do we work with \texttt{bindmany}? I know
we can now define \texttt{lammany} as follows, but how about the typing
rules?

\begin{verbatim}
lammany : bindmany term term \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} Well, for the built-in single binding type, we used three
built-in operations:

\begin{itemize}
\tightlist
\item
  variable substitution, encoded through HOAS function application
\item
  introducing a fresh variable, through the predicate form
  \texttt{x:term\ \ensuremath{\to}\ ...}
\item
  introducing a new assumption, through the predicate form
  \texttt{P\ \ensuremath{\to}\ ...}
\end{itemize}

\heroSTUDENT{} So we should add three operations for \texttt{bindmany} that
correspond to those, right?

\heroADVISOR{} Correct, and they will be predicates, since that's the only
kind of computation we can define in \foreignlanguage{greek}{位}Prolog. So let's first do the
predicate that generalizes application:

\begin{verbatim}
applymany : bindmany A B \ensuremath{\to} list A \ensuremath{\to} B \ensuremath{\to} prop.
applymany (bindbase Body) [] Body.
applymany (bindnext F) (HD :: TL) Body :- applymany (F HD) TL Body.
\end{verbatim}

\heroSTUDENT{} I see, so given a \texttt{bindmany} and a substitution for the
variables, perform simultaneous substitution to get the body.

\heroADVISOR{} Right. And a predicate for introducing multiple variables at
once. Then you try doing multiple assumptions.

\begin{verbatim}
intromany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} prop) \ensuremath{\to} prop.
intromany (bindbase _) P :- P [].
intromany (bindnext F) P :- (x:A \ensuremath{\to} intromany (F x) (fun tl \ensuremath{\Rightarrow} P (x :: tl))).
\end{verbatim}

\heroSTUDENT{} Let me see. So pattern match on the two cases, introducing an
extra assumption in the \texttt{bindnext} case. How does this look?

\begin{verbatim}
assumemany : (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} list A \ensuremath{\to} list B \ensuremath{\to} prop \ensuremath{\to} prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y \ensuremath{\to} assumemany P XS YS Q).
\end{verbatim}

\heroADVISOR{} That looks good. Maybe one thing to note is that this last rule
might not work in other \foreignlanguage{greek}{位}Prolog implementations, as it introduces an
assumption for a predicate that is not known statically, and that is
usually not allowed. That's why I said we should use Makam.

\heroSTUDENT{} Is that a limitation that has to do with the correspondence of
\foreignlanguage{greek}{位}Prolog to logic?

\heroADVISOR{} Not really; I believe it is because of implementation concerns
mostly -- it would significantly complicate designing an abstract
machine for the language. But Makam is interpreted, so it sidesteps
that.

\heroSTUDENT{} Interesting. So let me try doing the typing rule now. I'll add
a type for multiple-argument functions. Would this work?

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.
typeof (lammany F) (arrowmany TS T') :-
  intromany F (fun xs \ensuremath{\Rightarrow} applymany F xs Body, assumemany typeof xs TS (typeof Body T')).
\end{verbatim}

\heroADVISOR{} Almost. There is an issue here: the unification variable
\texttt{Body} cannot capture the free variables \texttt{xs} that get
introduced later. A unification variable is allowed to capture all the
free variables in scope at the point where it is introduced. By default,
they get introduced when we check whether a rule fires, but here we need
to say explicitly that \texttt{Body} should be introduced when
\texttt{intromany} uses its predicate argument; Makam uses
square-bracket notation for that. Oh, and a Makam idiosyncrasy: the
parser isn't clever enough to tell that the predicate argument to
\texttt{intromany} is, in fact, a predicate, so we can't use the normal
predicate syntax for it. There is the syntactic form \texttt{pfun} for
anonymous predicates; save for predicate syntax, it's entirely identical
to \texttt{fun}. So:

\begin{verbatim}
typeof (lammany F) (arrowmany TS T') :-
  intromany F (pfun xs \ensuremath{\Rightarrow} ([Body]
    applymany F xs Body, assumemany typeof xs TS (typeof Body T'))).
\end{verbatim}

\heroSTUDENT{} Oh, so \texttt{{[}Body{]}} is like existential quantification.
I wonder, would it make sense to combine \texttt{intromany} and
\texttt{appmany} into one predicate, like this, since we will probably
always need both the variables and the body of a \texttt{bindmany}?

\begin{verbatim}
openmany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
openmany F P :- intromany F (pfun xs \ensuremath{\Rightarrow} [Body] applymany F xs Body, P xs Body).
\end{verbatim}

\heroADVISOR{} Yes, that predicate turns out to be quite useful. Let's try out
a query now!

\begin{verbatim}
typeof (lammany (bindnext (fun x \ensuremath{\Rightarrow} bindnext (fun y \ensuremath{\Rightarrow} bindbase (tuple [y, x]))))) T ?
>> Yes:
>> T := arrowmany [T1, T2] (product [T2, T1]).
\end{verbatim}

\heroSTUDENT{} Great, I think I got the hang of this. We could definitely add
a multiple-argument application construct \texttt{appmany} or define the
rules for \texttt{eval} for these. But that would be easy; we can do it
later. Something that worries me, though -- all these fancy higher-order
abstract binders, how do we \ldots{} make them concrete? Say, how do we
print them?

\heroADVISOR{} That's actually quite easy. We just add a concrete name to
them. A plain old \texttt{string}. Our typing rules etc. do not care
about it, but we could use it for parsing concrete syntax into our
abstract binding syntax, or for pretty-printing\ldots{}. Let's not get
into that for the time being, but let's just say that we could have
defined \texttt{bindnext} with an extra \texttt{string} argument; and
then \texttt{intromany} and friends would just ignore it.

\begin{verbatim}
bindnext : string \ensuremath{\to} (Variable \ensuremath{\to} bindmany Variable Body) \ensuremath{\to} bindmany Variable Body.
\end{verbatim}

\heroSTUDENT{} Interesting. I would like to see more about this, but maybe
some other time. I thought of another thing that could be challenging:
mutually recursive \texttt{let\ rec}s?

\heroADVISOR{} Sure -- how about this?

\begin{verbatim}
letrec : bindmany term (list term * term) \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Bind many terms into a list of terms and a term. I guess
\texttt{*} is for tuples\ldots{} Is the first element the definitions
and the second element the body?

\heroADVISOR{} Yes -- so, for this expression \ldots{}

\begin{verbatim}
let rec f = f_def and g = g_def in body
\end{verbatim}

\heroSTUDENT{} \ldots{} we would write something like this:

\begin{verbatim}
letrec (bindnext (fun f \ensuremath{\Rightarrow} bindnext (fun g \ensuremath{\Rightarrow} bindbase ([f_def, g_def], body))))
\end{verbatim}

\heroADVISOR{} Yes, and we need to be careful so that the number of binders
matches the number of definitions in the list. We can go ahead and
encode that in our typing rules\ldots{}.

\heroSTUDENT{} Wait. I let you get away before with the zero binders in
\texttt{bindmany}, but this is pushing it a little bit. It doesn't sound
like an accurate encoding.

\heroADVISOR{} You're right, but we would need some sort of dependency to
enforce those kinds of limitations\ldots{} and \foreignlanguage{greek}{位}Prolog does not have
dependent types.

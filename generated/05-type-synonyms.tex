\section{Where our heroes reflect on structural
recursion}\label{where-our-heroes-reflect-on-structural-recursion}

\heroSTUDENT{} Type synonyms? Difficult? Why? Doesn't this work?

\begin{verbatim}
type_synonym : dbind typ T typ \ensuremath{\to} (typeconstructor T \ensuremath{\to} program) \ensuremath{\to} program.
type_synonym_info : typeconstructor T \ensuremath{\to} dbind typ T typ \ensuremath{\to} prop.

wfprogram (type_synonym Syn Program') :-
  (t:(typeconstructor T) \ensuremath{\to} type_synonym_info t Syn \ensuremath{\to}
    wfprogram (Program' t)).
\end{verbatim}

\heroADVISOR{} Sure, that works. How about the typing rule for them, then?
We'll need something like the conversion rule:

\begin{center}$\inferrule{\Gamma \vdash e : \tau \\ \tau =_{\delta} \tau'}{\Gamma \vdash e : \tau'}$\end{center}

\heroSTUDENT{} Right, \(=_{\delta}\) is equality up to expanding the type
synonyms.

\heroADVISOR{} Yes, we'll definitely need a type-equality predicate.

\begin{verbatim}
teq : typ \ensuremath{\to} typ \ensuremath{\to} prop.
\end{verbatim}

\heroSTUDENT{} OK. And then we do this?

\begin{verbatim}
typeof E T :- typeof E T', teq T T'.
\end{verbatim}

\heroADVISOR{} That would be nice, but we'll go into an infinite loop if that
rule gets used.

\heroSTUDENT{} Oh. Oh, right. There is a specific proof-finding strategy in
logic programming, and it can't always work\ldots{}. I guess we have to
switch our rules to an algorithmic type system instead.

\heroADVISOR{} Precisely. Well, luckily, we can do that to a certain extent,
without rewriting everything. Consider this: we only need to use the
conversion rule in cases where we already know something about the type
\texttt{T} of the expression, but our typing rules do not match that
type.

\heroSTUDENT{} Oh. Do you mean that in bi-directional typing terms? So, doing
type analysis of an expression with a concrete type \texttt{T} might
fail, but synthesizing the type anew could work?

\heroADVISOR{} Exactly, and in that case we have to check that the two types
are equal, using \texttt{teq}. So we need to change the rule you wrote
to apply only in the case where \texttt{T} starts with a concrete
constructor, rather than when it is an uninstantiated unification
variable.

\heroSTUDENT{} Is that even possible? Is there a way in \foreignlanguage{greek}{λ}Prolog to tell
whether something is a unification variable?

\heroADVISOR{} There is! Most Prolog dialects have a predicate that does that
-- it's usually called \texttt{var}. In Makam it is called
\texttt{refl.isunif}, the \texttt{refl} namespace prefix standing for
\emph{reflective} predicates. So a second attempt would be this:

\begin{verbatim}
typeof E T :- not(refl.isunif T), typeof E T', teq T T'.
\end{verbatim}

\heroSTUDENT{} Interesting. But wouldn't this lead to an infinite loop, too?
After all, \texttt{teq} is reflexive -- so we could end up in the same
situation as before.

\heroADVISOR{} Correct: for every proof of
\texttt{typeof\ E\ T\textquotesingle{}} through the other rules, a new
proof using this rule will be discovered, which will lead to another
proof for it, etc. One fix is to make sure that this rule is only used
once at the end, if typing using the normal rules fails.

\heroSTUDENT{} So, something like this:

\begin{verbatim}
typeof, typeof_cases, typeof_conversion : term \ensuremath{\to} typ \ensuremath{\to} prop.
typeof E T :- if (typeof_cases E T) then success else (typeof_conversion E T).
typeof_cases (app E1 E2) T' :- typeof E1 (arrow T1 T2), typeof E2 T1.
...
typeof_conversion E T :- not(refl.isunif T), typeof_cases E T', teq T T'.
\end{verbatim}

\heroADVISOR{} Yes, but let's do a trick to side-step the issue for now. We
will force the rule to only fire once for each expression \texttt{E}, by
remembering that we have used the rule already:

\begin{verbatim}
already_in : [A] A \ensuremath{\to} prop.
typeof E T :- not(refl.isunif T), not(already_in (typeof E)),
              (already_in (typeof E) \ensuremath{\to} typeof E T'), teq T T'.
\end{verbatim}

\heroSTUDENT{} If we ever made a paper submission out of this, the reviewers
would not be happy about this rule. But sure. We still need to define
\texttt{teq} now. Oh, and we should add the conversion rule for
patterns, but that's almost identical as for terms. (\ldots{}) I'll do
\texttt{teq}\ldots{}.

\begin{verbatim}
teq (tconstr TC Args) T' :- type_synonym_info TC Syn, applymany Syn Args T, teq T T'.
teq T' (tconstr TC Args) :- type_synonym_info TC Syn, applymany Syn Args T, teq T' T.
teq (arrow T1 T2) (arrow T1' T2') :- teq T1 T1', teq T2 T2'.
teq (arrowmany TS T) (arrowmany TS' T') :- map teq TS TS', teq T T'.
...
\end{verbatim}

\heroADVISOR{} Writing boilerplate is not fun, is it?

\heroSTUDENT{} It is not. I wish we could just write the first two rules; they
are the important ones, after all. All the other ones just propagate the
structural recursion through. Also, whenever we add a new constructor
for types, we'll have to remember to add a \texttt{teq} rule for
it\ldots{}.

\heroADVISOR{} Why don't we reflect a bit on this? Ideally we would only write
a generic rule, to handle any concrete constructor applied to a number
of arguments. Something like:

\begin{verbatim}
teq (Constructor Arguments) (Constructor Arguments') :- map teq Arguments Arguments'.
\end{verbatim}

\heroSTUDENT{} Right, so in the example of the \texttt{arrow} type,
\texttt{Constructor} would match \texttt{arrow} and arguments would be
instantiated with \texttt{{[}T1,\ T2{]}}. But we are not really
guaranteed that all arguments are of \texttt{typ} type, or even that
they are all of the same type, right? Take \texttt{arrowmany} for
example! The argument list needs to be heterogeneous.

\heroADVISOR{} Glad you figured that out. We can do that using the existential
type -- let's call it \texttt{dyn} --, so the arguments can be of
\texttt{list\ dyn} type. And we'll need to make \texttt{teq}
polymorphic:

\begin{verbatim}
dyn : type.
dyn : A \ensuremath{\to} dyn.
teq : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
\end{verbatim}

\heroSTUDENT{} We'll also need a \texttt{map} for these heterogeneous lists,
too. I believe it will need a polymorphic function as an argument, so
that it can be used at different types for different elements of the
list. So something like this:

\begin{verbatim}
map : (forall A. [A] A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} list dyn \ensuremath{\to} list dyn \ensuremath{\to} prop.
\end{verbatim}

\heroADVISOR{} Right, we'd need higher-rank types here. There's a problem with

\begin{verbatim}
map : [A] (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} list dyn \ensuremath{\to} list dyn \ensuremath{\to} prop
\end{verbatim}

In the first \texttt{cons} cell, this would instantiate the type
\texttt{A} to the type of the first element of the list, making further
applications to different types impossible.

\heroSTUDENT{} Exactly. Does Makam support higher-rank polymorphism?

\heroADVISOR{} Unfortunately it does not right now, but it should. Nor do any
other \foreignlanguage{greek}{λ}Prolog implementations that I know of, though. Also, there is no
way to refer to a polymorphic constant without implicitly instantiating
it with new type variables. So we have to use a helper predicate right
now, called \texttt{dyn.call}, to avoid that issue:

\begin{verbatim}
dyn.call : [B] (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.
dyn.map : (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} list dyn \ensuremath{\to} list dyn \ensuremath{\to} prop.
dyn.map P [] [].
dyn.map P (HD :: TL) (HD' :: TL') :- dyn.call P HD HD', dyn.map P TL TL'.
\end{verbatim}

\heroSTUDENT{} Fair enough. So, going back to our generic rule -- is there a
way to actually write it? Maybe there's another reflective predicate we
can use?

\heroADVISOR{} Exactly -- there is \texttt{refl.headargs}. If a term is
concrete, it decomposes it into a constructor and a list of
arguments\footnote{Other versions of Prolog have predicates toward the same effect; for example, SWI-Prolog \citep{wielemaker2012swi} provides `\texttt{compound\_{}name\_{}arguments}', which is quite similar.}.
This isn't a hack, though: we could define \texttt{refl.headargs}
without any special support, save for \texttt{refl.isunif}, if we
maintained a discipline whenever we add a new constructor:

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.
refl.headargs Term Head Args :- not(refl.isunif Term), eq Term (arrowmany TS T),
                                eq Head arrowmany, eq Args [TS, T].
\end{verbatim}

\heroSTUDENT{} So \texttt{refl.headargs} has this type:

\begin{verbatim}
refl.headargs : B \ensuremath{\to} A \ensuremath{\to} list dyn \ensuremath{\to} prop.
\end{verbatim}

\heroADVISOR{} Correct. We should now be able to proceed to defining the
boilerplate generically. Let's do it as a reusable higher-order
predicate for structural recursion. I'll give you the type; you fill in
the first case:

\begin{verbatim}
structural_recursion : [A B] (A \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.
\end{verbatim}

\heroSTUDENT{} Let me see. Oh, so, the first argument -- are we doing this in
open-recursion style? Maybe that's the predicate for recursive calls. I
need to deconstruct a term, apply the recursive call\ldots{}. How is
this?

\begin{verbatim}
structural_recursion Rec X Y :-
  refl.headargs X Constructor Arguments,
  dyn.map Rec Arguments Arguments',
  refl.headargs Y Constructor Arguments'.
\end{verbatim}

\heroAUDIENCE{} I'm sure this was not your first attempt in the unabridged
version of this story!

\heroADVISOR{} Wait, who said that? Anyway. That looks great! And you're right
about using \texttt{refl.headargs} in the other direction, to
reconstruct a new term with the same constructor and different
arguments.

\heroSTUDENT{} Are we done?

\heroADVISOR{} Almost there! We just need to handle the case of the meta-level
function type. We cannot destructure functions using
\texttt{refl.headargs}, so we have to treat them specially:

\begin{verbatim}
structural_recursion Rec (X : A \ensuremath{\to} B) (Y : A \ensuremath{\to} B) :-
  (x:A \ensuremath{\to} structural_recursion Rec x x \ensuremath{\to} structural_recursion Rec (X x) (Y x)).
\end{verbatim}

\heroSTUDENT{} This is exciting; I hope it is part of the standard library of
Makam. I can do \texttt{teq} in a few lines now!

\begin{verbatim}
teq' : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
teq T T' :- teq' T T'.

teq' (tconstr TC Args) T' :-
  type_synonym_info TC Synonym, applymany Synonym Args T, teq' T T'.
teq' T' (tconstr TC Args) :-
  type_synonym_info TC Synonym, applymany Synonym Args T, teq' T' T.
teq' T T' :- structural_recursion teq' T T'.
\end{verbatim}

\heroADVISOR{} That is exactly right! So, we've minimized the boilerplate, and
we won't need any adaptation when we add a new constructor -- even if we
make use of all sorts of new and complicated types.

\heroSTUDENT{} That's right: we did not do anything special for the binding
forms we defined\ldots{}. quite a payoff for a small amount of code!
But, wait, isn't \texttt{structural\_recursion} missing a case: that of
uninstantiated unification variables?

\heroADVISOR{} It is, but in my experience, it's better to define how to
handle unification variables as needed, in each new structurally
recursive predicate. In this case, we're only supposed to use
\texttt{teq} with ground terms, so it's fine if we fail when we
encounter a unification variable.

\begin{scenecomment}
(Our heroes try out a few examples and convince themselves that this works OK and no endless loops happen when things don't typecheck correctly.)
\end{scenecomment}

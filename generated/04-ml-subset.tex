\section{Where our heroes add more ML features and reflect on structural
recursion}\label{where-our-heroes-add-more-ml-features-and-reflect-on-structural-recursion}

\begin{scenecomment}
(Our heroes need a small break, so they work on a few features as an improvisation based on the Rast makam. Roza is singing, and Hagop is playing the oud.)
\end{scenecomment}

\begin{verse}
``Explicit System F polymorphism is easy, at some point we'll do Hindley-Milner too. \\
Types are well-formed by construction, an extra $\vdash \tau \; \text{wf}$ judgement we won't do. \\
The implicit assumptions context is great, no need to thread an extra type context $\Delta$ through.''
\end{verse}

\begin{verbatim}
forall : (typ \ensuremath{\to} typ) \ensuremath{\to} typ.
lamt : (typ \ensuremath{\to} term) \ensuremath{\to} term.
appt : term \ensuremath{\to} typ \ensuremath{\to} term.
typeof (lamt E) (forall T) :- (a:typ \ensuremath{\to} typeof (E a) (T a)).
typeof (appt E T) (TF T) :- typeof E (forall TF).
\end{verbatim}

\begin{verse}
``We are now adding top-level programs, to get into datatype declarations. \\
We would rather do modules, but those would need quite a bit of deliberation. \\
And we still got contextual types to do, those will require our full attention.''
\end{verse}

\begin{verbatim}
program : type.
wfprogram : program \ensuremath{\to} prop.

let : term \ensuremath{\to} (term \ensuremath{\to} program) \ensuremath{\to} program.
wfprogram (let E P) :- typeof E T, (x:term \ensuremath{\to} typeof x T \ensuremath{\to} wfprogram (P x)).

main : term \ensuremath{\to} program.
wfprogram (main E) :- typeof E _.
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Let us now proceed to algebraic datatypes. A datatype has a name, a
number of type parameters, and a list of constructors; constructors
themselves have names and lists of arguments:

\begin{verbatim}
typeconstructor : type \ensuremath{\to} type.
constructor : type.

ctor_declaration : type \ensuremath{\to} type.
nil : ctor_declaration unit.
cons : list typ \ensuremath{\to} ctor_declaration T \ensuremath{\to}
         ctor_declaration (constructor * T).
datatype_declaration : type \ensuremath{\to} type \ensuremath{\to} type.
datatype_declaration : 
  (typeconstructor Arity \ensuremath{\to} dbind typ Arity (ctor_declaration Constructors)) \ensuremath{\to}
  datatype_declaration Arity Ctors.

datatype :
  datatype_declaration Arity Constructors \ensuremath{\to}
  (typeconstructor Arity \ensuremath{\to} dbind constructor Constructors program) \ensuremath{\to}
  program.
\end{verbatim}

The datatype introduces a type constructor, as well as a number of
constructors, in the rest of the program. Here we use dependency to
carry the arity of the type constructor in its meta-level type, avoiding
the need for a well-formedness predicate for types. Of course, in
situations where object-level types are more complicated, we would need
to incorporate kind checking into our predicates.

Let us now proceed to well-formedness for datatype declarations. We will
need two auxiliary predicates: one that keeps information about a
constructor -- which type it belongs to, what arguments it expects; and
another one that abstracts over the type variables used in the datatype
declaration, creating a polymorphic type for the type of the
constructor, which can be instantiated with different types at different
places.

\begin{verbatim}
constructor_info :
  typeconstructor Arity \ensuremath{\to} constructor \ensuremath{\to} dbind typ Arity (list typ) \ensuremath{\to} prop.

constructor_polytypes : [Arity Ctors PolyTypes]
  subst typ Arity \ensuremath{\to}
  ctor_declaration Ctors \ensuremath{\to} subst (dbind typ Arity (list typ)) PolyTypes \ensuremath{\to} prop.

constructor_polytypes _ [] [].
constructor_polytypes TypVars (CtorType :: CtorTypes) (PolyType :: PolyTypes) :-
  applymany PolyType TypVars CtorType,
  constructor_polytypes TypVars CtorTypes PolyTypes.
\end{verbatim}

One interesting part intereaction is in the two \texttt{applymany}
calls: these are used in the opposite direction than what we have used
it so far, getting \texttt{TypVars} and \texttt{CtorType} as inputs and
producing \texttt{PolyType} as an output. We need to be careful, though,
to make sure that \texttt{PolyType} cannot capture the \texttt{TypVars}
variables:

\begin{verbatim}
wfprogram (datatype (datatype_declaration ConstructorDecls) Program') :-
  (dt:(typeconstructor T) \ensuremath{\to} ([PolyTypes]
    openmany (ConstructorDecls dt) (pfun tvars constructor_decls \ensuremath{\Rightarrow} (
      constructor_polytypes tvars constructor_decls PolyTypes)),
    openmany (Program' dt) (pfun constructors program' \ensuremath{\Rightarrow}
      assumemany (constructor_info dt) constructors PolyTypes
      (wfprogram program')))).
\end{verbatim}

In order to be able to refer to datatypes and constructors, we will need
type- and term-level formers.

\begin{verbatim}
tconstr : typeconstructor T \ensuremath{\to} subst typ T \ensuremath{\to} typ.
constr : constructor \ensuremath{\to} list term \ensuremath{\to} term.

typeof (constr Constructor Args) (tconstr TypConstr TypArgs) :-
  constructor_info TypConstr Constructor PolyType,
  applymany PolyType TypArgs Typs,
  map typeof Args Typs.
\end{verbatim}

We will also need patterns:

\begin{verbatim}
patt_constr : constructor \ensuremath{\to} pattlist T T' \ensuremath{\to} patt T T'.

typeof (patt_constr Constructor Args) S' S (tconstr TypConstr TypArgs) :-
  constructor_info TypConstr Constructor PolyType,
  applymany PolyType TypArgs Typs,
  typeof Args S' S Typs.
\end{verbatim}

As an example, we will define lists and their append function:

\begin{verbatim}
wfprogram
  (datatype
    (datatype_declaration (fun llist \ensuremath{\Rightarrow} dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (
    [ [] (* nil *) ,
      [a, tconstr llist [a]] (* cons of a * list a *) ]))))
  (fun llist \ensuremath{\Rightarrow} dbindnext (fun lnil \ensuremath{\Rightarrow} dbindnext (fun lcons \ensuremath{\Rightarrow} dbindbase (
  (main
    (letrec
      (dbindnext (fun append \ensuremath{\Rightarrow} dbindbase (
      [ lamt (fun a \ensuremath{\Rightarrow} lam (tconstr llist [a]) (fun l1 \ensuremath{\Rightarrow} lam _ (fun l2 \ensuremath{\Rightarrow}
        case_or_else l1
          (patt_constr lcons [patt_var, patt_var])
            (dbindnext (fun hd \ensuremath{\Rightarrow} dbindnext (fun tl \ensuremath{\Rightarrow} dbindbase (
            constr lcons [hd, app (app (appt append _) tl) l2]))))
          l2))) ])))
      (dbindnext (fun append \ensuremath{\Rightarrow} dbindbase (
    (app (app (appt append _)
      (constr lcons [zero, constr lnil []]))
      (constr lcons [zero, constr lnil []]))
)))))))))) ?
\end{verbatim}

The semantics, if needed:

\begin{verbatim}
patt_to_term (patt_constr Constructor Args) (constr Constructor Args') S' S :-
  pattlist_to_termlist Args Args' S' S.

eval (constr C Args) (constr C Args') :-
  map eval Args Args'.

eval : program \ensuremath{\to} program \ensuremath{\to} prop.

eval (let E P') P'' :-
  eval E V, eval (P' V) P''.

eval (datatype D P') (datatype D P'') :-
  (dt:(typeconstructor T) \ensuremath{\to}
    intromany CS (pfun cs \ensuremath{\Rightarrow} ([P'c P''c]
    applymany (P' dt) cs P'c,
    applymany (P'' dt) cs P''c,
    eval P'c P''c))).

eval (main E) (main V) :-
  eval E V.
\end{verbatim}

Example:

\begin{verbatim}
(eq _PROGRAM (

    (datatype
      (datatype_declaration (fun llist \ensuremath{\Rightarrow} dbindnext (fun a \ensuremath{\Rightarrow} dbindbase (
      [ [] (* nil *) ,
        [a, tconstr llist [a]] (* cons of a * list a *) ]))))
      (fun llist \ensuremath{\Rightarrow} dbindnext (fun lnil \ensuremath{\Rightarrow} dbindnext (fun lcons \ensuremath{\Rightarrow} dbindbase (

    (main (constr lcons [zero, constr lnil []]))

    )))))),

 wfprogram _PROGRAM,
 eval _PROGRAM FINAL) ?
\end{verbatim}

\section{Where our heroes tackle a new level of meta, dependencies, and
contexts}\label{where-our-heroes-tackle-a-new-level-of-meta-dependencies-and-contexts}

\heroSTUDENT{} I'm fairly confident by now that Makam should be able to handle
the research idea we want to try out. Shall we get to it?

\heroADVISOR{} Yes, it is time. So, what we are aiming to do is add a facility
for type-safe, heterogeneous meta-programming to our object language,
similar to MetaHaskell \citep{mainland2012explicitly}. This way we can
manipulate the terms of a \emph{separate} object language in a type-safe
manner.

\heroSTUDENT{} Exactly. We aim for our object language to be a formal logic,
so our language will be similar to Beluga \citep{beluga-main-reference}
or VeriML \citep{veriml-main-reference}. We'll have to be able to
pattern match over the terms of the object language, so they will be
runtime entities, rather than erasable static entities\ldots{}. But we
don't need to do all of that; let's just do a basic version for now, and
I can do the rest on my own.

\newcommand\dep[1]{\ensuremath{#1}}
\newcommand\lift[1]{\ensuremath{\langle#1\rangle}}
\newcommand\odash[0]{\ensuremath{\vdash_{\text{o}}}}
\newcommand\wf[0]{\ensuremath{\; \text{wf}}}
\newcommand\aq[1]{\ensuremath{\texttt{aq}(#1)}}

\heroADVISOR{} Sounds good. Still, we should use the generic dependently-typed
framework that we have come up with. But before we get to that, let's
agree on some terminology first, because a lot of words are getting
overloaded a lot. Let us call \emph{objects} \(o\) any sorts of terms of
the object language that we will be manipulating. And, for a lack of a
better word, let us call \emph{classes} \(c\) any sort of types that
characterize those objects through a typing relation of the form
\(\Psi \odash o : c\). It is unfortunate that these names suggest
object-orientation, but this is not the intent.

\heroSTUDENT{} I see what you are saying. In the language we have in mind, the
objects, as you just defined them, include both terms and types; and as
a result, the classes should be types (characterizing terms) and kinds
(characterizing types). Now, I think the fragment that we should do is
this: we should have dependent functions over the objects, where one
object can depend on another one. We need the dependency so that, for
example, we can take an object type \texttt{T} as an argument and return
an object term of that exact type \texttt{T}. Dependent products should
be similar, but we can skip them for now and just add a way to return
(or ``lift'') an object \(o\) as a meta-level value \(\lift{o}\).

\heroADVISOR{} Good idea. We are getting into many levels of meta -- there's
the meta-language we're using, Makam; there's the object language we are
encoding, which is now becoming a meta-language in itself, let's call
that Heterogeneous Meta ML Light (HMML?); and there's the
``object-object'' language that HMML is manipulating. And let's keep
that last one simple: the simply typed lambda calculus (STLC).

\heroSTUDENT{} Great. Other options for the language of objects could be -- a
language of natural numbers, equality predicates, and equality proofs,
which would be quite similar to the Dependent ML formulation of
\citet{licata2005formulation}; or it could even be the terms of the full
meta-language itself, which would be more similar to a homogeneous,
multi-stage language like MetaML \citep{metaml-main-reference}. But in
this case, our objects will be the types and terms of STLC -- actually,
the open terms of STLC. But as a first example, we can just do something
that is more standard, where we only need the closed terms as objects.
How about the standard example of a staged \texttt{power} function?
Here's a sketch, where I'm using \texttt{\textasciitilde{}I} for
antiquotation:

\begin{verbatim}
let power (n: onat): < stlc.arrow stlc.onat stlc.onat > =
  match n with
    0 \ensuremath{\Rightarrow} < stlc.lam (fun x \ensuremath{\Rightarrow} 1) >
  | S (S n') \ensuremath{\Rightarrow} letobj I = power n' in
      < stlc.lam (fun x \ensuremath{\Rightarrow} stlc.app ~I (stlc.mult x x)) >
  | S n' \ensuremath{\Rightarrow} letobj I = power n' in
      < stlc.lam (fun x \ensuremath{\Rightarrow} stlc.mult (stlc.app ~I x) x) >
\end{verbatim}

\heroADVISOR{} It's a plan. So, let's get to it. Should we write some of the
system down on paper first?

\heroSTUDENT{} Yes, that will be necessary. For this example, we need only the
lifting construct and the \texttt{letobj} typing rules; we will work on
dependent functions afterwards. Here are their typing rules, which
depend on an appropriately defined typing judgment \(\Psi \odash o : c\)
for objects. We use \(\dep{i}\) for variables standing for objects,
which we will call \emph{indices}. And we will need a way to antiquote
indices inside STLC terms, which means that we will have to
\emph{extend} the objects as well as their typing judgment
\(\dep{\Psi} \odash o : c\) accordingly.

\vspace{-1.5em}\begin{mathpar}
\begin{array}{ll}
\rulename{Ob-Ob-Syntax}                                                   & \rulename{HMML-Syntax} \\
\dep{o} ::= (\text{...closed terms of STLC, plus }\aq{\dep{i}}\text{...}) & e ::= \text{...} \; | \; \lift{\dep{o}} \; | \; \texttt{letobj} \; \dep{i} = \dep{o} \; \texttt{in} \; e \\
\dep{o} ::= \text{(...types of STLC...)}                                  & \tau ::= \text{...} \; | \; \lift{\dep{c}}
\end{array} \\

\inferrule[Typeof-LiftObj]
          {\dep{\Psi} \odash \dep{o} : \dep{c}}
          {\Gamma; \dep{\Psi} \vdash \lift{\dep{o}} : \lift{\dep{c}}}

\inferrule[Typeof-LetObj]
          {\Gamma; \dep{\Psi} \vdash e : \lift{\dep{c}} \\ \Gamma; \dep{\Psi}, \; \dep{i} : \dep{c} \vdash e : \tau \\ i \not\in \text{fv}(\tau)}
          {\Gamma; \dep{\Psi} \vdash \texttt{letobj} \; \dep{i} = e \; \texttt{in} \; e' : \tau}

\inferrule[Classof-Antiquote]
          {\dep{i} : \dep{c} \in \Psi}
          {\Psi \odash \aq{\dep{i}} : \dep{c}}
          
\inferrule[Eval-LiftObj]
          {\hspace{1em}}{\lift{\dep{o}} \Downarrow \lift{\dep{o}}}

\inferrule[Eval-LetObj]
          {e \Downarrow \lift{\dep{o}} \\ e'[\dep{o}/\dep{i}] \Downarrow v}
          {\texttt{letobj} \; \dep{i} = e \; \texttt{in} \; e' \Downarrow v}

\inferrule[SubstObj]{}{
  e[\dep{o}/\dep{i}] = e' \; \text{defined by structural recursion, save for:} \; {\bf{\aq{\dep{i}}[\dep{o}/\dep{i}] = \dep{o}}}
}
\end{mathpar}

The typing rules should be quite simple to transcribe to Makam:

\begin{verbatim}
object, class, index : type.
classof : object \ensuremath{\to} class \ensuremath{\to} prop.
classof_index : index \ensuremath{\to} class \ensuremath{\to} prop.
subst_obj : (I_E: index \ensuremath{\to} term) (O: object) (E_O'I: term) \ensuremath{\to} prop.

liftobj : object \ensuremath{\to} term. liftclass : class \ensuremath{\to} typ.
typeof (liftobj O) (liftclass C) :- classof O C.

letobj : term \ensuremath{\to} (index \ensuremath{\to} term) \ensuremath{\to} term.
typeof (letobj E EF') T :-
  typeof E (liftclass C), (i:index \ensuremath{\to} classof_index i C \ensuremath{\to} typeof (EF' i) T).

eval (liftobj O) (liftobj O).
eval (letobj E I_E') V :-
  eval E (liftobj O), subst_obj I_E' O E', if (refl.isunif E') then (print "not fixed", failure) else success, eval E' V.
\end{verbatim}

\heroADVISOR{} Great. I'll add the object language in a separate namespace
prefix -- we can use `\texttt{\%extend}' for going into a namespace --
and I'll just copy-paste our STLC code from earlier on. Let me also add
our new antiquote as a new STLC term constructor!

\begin{verbatim}
%extend stlc.
term : type. typ : type. typeof : term \ensuremath{\to} typ \ensuremath{\to} prop.
...
aq : index \ensuremath{\to} term.
%end.
\end{verbatim}

\heroSTUDENT{} Time to add STLC terms as \texttt{object}s, and their types as
\texttt{class}es. We can then give the corresponding rule for
\texttt{classof}. And I think that's it for the typing rules!

\begin{verbatim}
obj_term : stlc.term \ensuremath{\to} object. cls_typ : stlc.typ \ensuremath{\to} class.
classof (obj_term E) (cls_typ T) :- stlc.typeof E T.
stlc.typeof (stlc.aq I) T :- classof_index I (cls_typ T).
\end{verbatim}

\begin{scenecomment}
(Hagop transcribes the example from before. Writing out the term is long, so finds himself
wishing that Makam supported some way to write terms of object languages in their native syntax;
curiously, he also finds himself wishing that he had a stack of blank pages.)
\end{scenecomment}

\begin{verbatim}
typeof (..long term..) T ?
>> Yes:
>> T := arrow onat (liftclass (cls_typ (stlc.arrow stlc.onat stlc.onat))).
\end{verbatim}

\input{generated/todo}

\heroADVISOR{} I will set up the structural recursion for \texttt{subst\_obj}
now. I have a trick up my sleeve I haven't told you about yet!

\begin{verbatim}
subst_obj_aux, subst_obj_cases : [Any]
  (Var: index) (Replace: object) (Where: Any) (Result: Any) \ensuremath{\to} prop.
subst_obj I_Typ O Typ_O'I :-
  (i:index \ensuremath{\to} subst_obj_aux i O (I_Typ i) Typ_O'I).

subst_obj_aux Var Replace Where Result :-
  if (refl.rules_apply (subst_obj_cases Var Replace Where Result))
  then (subst_obj_cases Var Replace Where Result)
  else (structural_recursion @(subst_obj_aux Var Replace) Where Result).

subst_obj_cases Var (obj_term Replace) (stlc.aq Var) Replace.
\end{verbatim}

\heroSTUDENT{} Are we done?

\heroTODO{} Fix the code!

\begin{verbatim}
wfclass : class \ensuremath{\to} prop.

lamdep : class \ensuremath{\to} (index \ensuremath{\to} term) \ensuremath{\to} term.
pidep : class \ensuremath{\to} (index \ensuremath{\to} typ) \ensuremath{\to} typ.
typeof (lamdep C EF) (pidep C TF) :-
  (i:index \ensuremath{\to} classof_index i C \ensuremath{\to} typeof (EF i) (TF i)), wfclass C.

appdep : term \ensuremath{\to} object \ensuremath{\to} term.
typeof (appdep E O) T' :-
  typeof E (pidep C TF), classof O C, subst_obj TF I T'.
\end{verbatim}

\begin{mathpar}
\inferrule[Typeof-LamObj]
          {\Gamma; \dep{\Psi}, \; \dep{i} : \dep{c} \vdash e : \tau \\ \dep{\Psi} \odash \dep{c} \; \text{wf}}
          {\Gamma; \dep{\Psi} \vdash \Lambda \dep{i} : \dep{c}.e : \Pi \dep{i} : \dep{c}.\tau}

\inferrule[Typeof-AppObj]
          {\Gamma; \dep{\Psi} \vdash e : \Pi \dep{i} : \dep{c}.\tau \\ \dep{\Psi} \odash \dep{o} : \dep{c}}
          {\Gamma; \dep{\Psi} \vdash e @ \dep{o} : \dep{\text{subst}}(\tau, [\dep{o}/\dep{i}])}
\end{mathpar}

\heroSTUDENT{} Great! I'll make these into dependent indices now, including
both types and terms.

\begin{verbatim}
iterm : stlc.term \ensuremath{\to} object.     ityp : stlc.typ \ensuremath{\to} object.
ctyp : stlc.typ \ensuremath{\to} class.  cext : class.
depclassify (iterm E) (ctyp T) :- stlc.typeof E T.
depclassify (ityp T) cext :- stlc.wftyp T.
depwf (ctyp T) :- stlc.wftyp T.
depwf cext.
\end{verbatim}

\heroADVISOR{} Right, we'll need to check that types are well-formed, too.
Right now, they are all well-formed by construction, but let's prepare
for any additions, by setting up a structurally recursive predicate. The
\texttt{wftyp\_cases} predicate will hold the important type-checking
cases, and we will have an extra predicate to say whether those cases
apply or not for a specific \texttt{typ}.

\begin{verbatim}
%extend stlc.
wftyp : typ \ensuremath{\to} prop. wftyp_aux : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
wftyp_cases, wftyp_applies : [A] A \ensuremath{\to} prop.
wftyp T :- wftyp_aux T T.
wftyp_aux T T :- if (wftyp_applies T)
                 then (wftyp_cases T)
                 else (structural_recursion wftyp_aux T T).
%end.
\end{verbatim}

\heroSTUDENT{} I see -- if a type-checking rule applies, but fails, we don't
want to proceed to also try structural recursion; it would defeat the
purpose. Neat trick. I also see that your structural recursion just
needs to do a simple visit and it does not need to produce an output;
hence the repeat of the same \texttt{typ} argument. Let's prepare for
substitutions, too, in the same way.

\begin{verbatim}
subst_obj_aux, depsubst_cases : [A] index \ensuremath{\to} object \ensuremath{\to} A \ensuremath{\to} A \ensuremath{\to} prop.
depsubst_applies : [A] index \ensuremath{\to} A \ensuremath{\to} prop.
depsubst F I Res :- (v:index \ensuremath{\to} subst_obj_aux v I (F v) Res).
subst_obj_aux Var Replace Where Res :-
  if (depsubst_applies Var Where)
  then (depsubst_cases Var Replace Where Res)
  else (structural_recursion (subst_obj_aux Var Replace) Where Res).
\end{verbatim}

\heroADVISOR{} Great! We only have one thing missing: we need to close the
loop, being able to refer to a dependent variable from within an
object-level term or type.

\heroSTUDENT{} I got this.

\begin{verbatim}
%extend stlc.
varterm : index \ensuremath{\to} term.  vartyp : index \ensuremath{\to} typ.
typeof (varterm V) T :- depclassify V (ctyp T).
wftyp_applies (vartyp V). wftyp_cases (vartyp V) :- depclassify V cext.
%end.
depsubst_applies Var (stlc.varterm Var).
depsubst_cases Var (iterm Replace) (stlc.varterm Var) Replace.
depsubst_applies Var (stlc.vartyp Var).
depsubst_cases Var (ityp Replace)  (stlc.vartyp Var)  Replace.
\end{verbatim}

\heroADVISOR{} This is exciting; let me try it out! I'll do a function that
takes an object-level type and returns the object-level identity
function for it.

\begin{verbatim}
typeof (lamdep cext (fun t \ensuremath{\Rightarrow}
         (liftdep (iterm (stlc.lam (stlc.vartyp t) (fun x \ensuremath{\Rightarrow} x)))))) T ?
>> Yes!!!!!
>> T := pidep cext (fun t \ensuremath{\Rightarrow}
>>        liftdep (ctyp (stlc.arrow (stlc.vartyp t) (stlc.vartyp t))))
\end{verbatim}

\heroSTUDENT{} Look, even the Makam REPL is excited!

\heroADVISOR{} Wait until it sees what we have in store for it next: open STLC
terms in our indices!

\heroSTUDENT{} Good thing I've printed out the contextual types paper by
\citet{nanevski2008contextual}. (\ldots{}) OK, so it says here that we
can use contextual types to record, at the type level, the context that
open terms depend on. So let's say, an open \texttt{stlc.term} of type
\(\tau\) that mentions variables of a \(\Phi\) context would have a
contextual type of the form \([\Phi] \tau\). This is some sort of modal
typing, with a precise context.

\heroADVISOR{} Right. So in our case, open STLC terms depend on a number of
variables, and we will need to keep track of the STLC types of those
variables, in order to maintain type safety. So, let's add a new
dependent index for open STLC terms, and a dependent classifier for
their contextual types, which record the types of the variables that the
term depends on, as well as the actual type of the term itself.

\heroSTUDENT{} Let me see. I think something like this is what we want:

\begin{verbatim}
iopen_term : bindmany stlc.term stlc.term \ensuremath{\to} stlc.
cctx_typ : list stlc.typ \ensuremath{\to} stlc.typ \ensuremath{\to} class.
\end{verbatim}

\heroADVISOR{} That looks right to me. I can write the classification and
well-formedness rules for those.

\begin{verbatim}
depclassify (iopen_term XS_E) (cctx_typ TS T) :-
  openmany XS_E (pfun xs e \ensuremath{\Rightarrow}
    assumemany stlc.typeof xs TS (stlc.typeof e T),
    foreach stlc.wftyp TS).
depwf (cctx_typ TS T) :- foreach stlc.wftyp TS, stlc.wftyp T.
\end{verbatim}

\heroSTUDENT{} That makes a lot of sense. I see you are also checking
well-formedness for the types that the context introduces; and
\texttt{foreach} is exactly like \texttt{map}, but there's no output, so
it applies a single-argument predicate to each element of the list.

\heroADVISOR{} Right. We now get to the tricky part: referring to variables
that stand for open terms within other terms! You know what those are,
right? Those are Object-level Object-level Meta-variables.

\heroSTUDENT{} My head hurts; I'm getting
\href{https://en.wikipedia.org/wiki/Out_of_memory}{OOM} errors. Maybe
this is easier to implement in Makam than to talk about.

\heroADVISOR{} Maybe so. Well, let me just say this: those variables will
stand for open terms that depend on a specific context \(\Phi\), but we
might use them at a different context \(\Phi'\). We need a
\emph{substitution} \(\sigma\) to go from the context they were defined
into the current context.

\heroSTUDENT{} OK, and then we need to apply that substitution \(\sigma\) when
we substitute an actual open term for the metavariable. I know what to
do:

\vspace{-0.5em}

\begin{verbatim}
%extend stlc.
varmeta : index \ensuremath{\to} list term \ensuremath{\to} term.
typeof (varmeta V ES) T :- depclassify V (cctx_typ TS T), map stlc.typeof ES TS.
%end.
depsubst_applies Var (stlc.varmeta Var _).
depsubst_cases Var (iopen_term XS_E) (stlc.varmeta Var ES) Result :-
  applymany XS_E ES E', subst_obj_aux Var (iopen_term XS_E) E' Result.
\end{verbatim}

\heroADVISOR{} That should be it; let's try this out! Let's do meta-level
application, maybe? So, take a ``function'' body that needs a single
argument, and an instantiation for that argument, and do the
substitution at the meta-level. This will be sort of like inlining. And
let's use unification variables wherever it makes sense, to push our
rules to infer what they can for themselves!

\begin{verbatim}
typeof (lamdep _ (fun t1 \ensuremath{\Rightarrow} (lamdep _ (fun t2 \ensuremath{\Rightarrow}
       (lamdep (cctx_typ [stlc.vartyp t1] (stlc.vartyp t2)) (fun f \ensuremath{\Rightarrow}
       (lamdep _ (fun a \ensuremath{\Rightarrow} (liftdep (iopen_term (bindbase (
         (stlc.varmeta f [stlc.varterm a]))))))))))))) T ?
>> Yes:
>> T := (pidep cext (fun t1 \ensuremath{\Rightarrow} pidep cext (fun t2 \ensuremath{\Rightarrow}
>>      (pidep (cctx_typ [stlc.vartyp t1] (stlc.vartyp t2)) (fun f \ensuremath{\Rightarrow}
>>      (pidep (ctyp (stlc.vartyp t1)) (fun a \ensuremath{\Rightarrow}
>>      (liftdep (cctx_typ [] (stlc.vartyp t2)))))))))).
\end{verbatim}

\begin{scenecomment}
(Our heroes try out a few more examples to convince themselves that this works.)
\end{scenecomment}

\heroSTUDENT{} That's it! That's it! I cannot believe how easy this was!

\heroAUDIENCE{} Neither can we believe that you thought this was easy!

\heroAUTHOR{} Trust me, you should have seen how many weeks it took me to
implement something like this in OCaml\ldots{}. it was enough to make me
start working on Makam. That took two years, but now we can at least
show it in 24 pages of a single-column PDF!

\heroADVISOR{} Where are all these voices coming from?

\heroSTUDENT{}
\textit{(Joke elided to avoid issues with double-blind submission.)}

\section{Where our hero Hagop adds pattern matching on his
own}\label{where-our-hero-hagop-adds-pattern-matching-on-his-own}

\heroTODO{}
\textcolor{red}{This is where I am! Haven't finished revising from here on.}

\heroSTUDENT{} I see. Say, can we use the same dependency trick to do
patterns?

\heroADVISOR{} We should be able to\ldots{} the linearity is going to be a bit
tricky, but I am fairly confident that having explicit support in our
metalanguage just for single-variable binding is enough to model most
complicated forms of binding, when we also make use of polymorphism and
GADTs.

\heroSTUDENT{} Makes sense. Well, I think I have an idea for patterns: we can
have a type argument to keep track of what variables they introduce.
Since within a pattern we can only refer to a variable once\ldots{} no
actual binding needs to take place. But we can use the type argument to
bind the right number of pattern variables into the body of a branch.

\heroADVISOR{} That is true\ldots{}. One way I think about binding is that it
is just a way to introduce a notion of sharing into abstract syntax
trees, so that we can refer to the same thing a number of times. And
you're right that for patterns, the sharing happens from the side of the
pattern into the branch body, not within the pattern itself.

\heroSTUDENT{} Though there is some of that in dependent pattern matching,
where you can reuse a pattern variable and an exact matching takes place
rather than unification\ldots{}.

\heroADVISOR{} \ldots{}Right. But let's not worry about that right now; let's
just do simple patterns. So at the top level, a pattern will just have a
single ``tuple type'' argument with the variables it used. I am thinking
that for sub-patterns, we will need two arguments. One for all the
variables that \emph{can} be used, initially matching the type argument
of the top-level pattern; another argument, for the variables that
\emph{remain} to be used after this sub-pattern is traversed.

\heroSTUDENT{} I don't get that yet. Wait, let me first add natural numbers as
a base type so that we have a simple example.

\begin{verbatim}
nat : typ. zero : term. succ : term \ensuremath{\to} term.
typeof zero nat. typeof (succ N) nat :- typeof N nat.
eval zero zero. eval (succ E) (succ V) :- eval E V.
\end{verbatim}

\heroADVISOR{} Good idea. OK, so here's what I meant:

\begin{verbatim}
patt : type \ensuremath{\to} type \ensuremath{\to} type.
patt_var : patt (term * T) T.
patt_zero : patt T T.
patt_succ : patt T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroSTUDENT{} Hmm. So, you said the first argument is what variables are
``available'' when we go into the sub-pattern, second is what we're
``left with''\ldots{} so in the variable case, we ``use up'' one
variable. In the zero case, we don't use any. And for successors, we
just propagate the variables.

\heroADVISOR{} Exactly. Could you do tuples?

\heroSTUDENT{} Let me see, I think I'll need a helper type for multiple
patterns\ldots{}.

\begin{verbatim}
pattlist : type \ensuremath{\to} type \ensuremath{\to} type.
nil : pattlist T T.
cons : patt T1 T2 \ensuremath{\to} pattlist T2 T3 \ensuremath{\to} pattlist T1 T3.
patt_tuple : pattlist T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroADVISOR{} Exactly! And here's an interesting one: wildcards.

\begin{verbatim}
patt_wild : patt T T.
\end{verbatim}

\heroSTUDENT{} Oh, because that does not really introduce any pattern
variables that we can use. So if I understand this correctly, top-level
patterns should always use up all their variables -- they should end
with the second argument being \texttt{unit}, right?

\heroADVISOR{} Exactly, so this should be fine for a single-branch
pattern-match construct:

\begin{verbatim}
case_or_else : term \ensuremath{\to} patt T unit \ensuremath{\to} dbind term T term \ensuremath{\to} term \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Let me parse that\ldots{} the first argument is the scrutinee,
the second is the pattern\ldots{} the third is the branch body, with the
pattern variables introduced. Oh, and the last argument is the
\texttt{else} case.

\heroADVISOR{} Right. And I think something like this should work for the
typing judgment. Let me write a few cases.

\begin{verbatim}
typeof : [T T' Ttyp T'typ] patt T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} typ \ensuremath{\to} prop.
typeof patt_var S' (cons T S') T.
typeof patt_wild S S T.
typeof patt_zero S S nat.
typeof (patt_succ P) S' S nat :- typeof P S' S nat.
\end{verbatim}

\heroSTUDENT{} I see, so given a pattern and the types of the variables
following the sub-pattern, we produce the types of all the variables and
the type of the pattern itself. Makes sense. I'll do tuples:

\begin{verbatim}
typeof : [T T' Ttyp T'typ]
  pattlist T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} list typ \ensuremath{\to} prop.
typeof (patt_tuple PS) S' S (product TS) :- typeof PS S' S TS.
typeof [] S S [].
typeof (P :: PS) S3 S1 (T :: TS) :- typeof PS S3 S2 TS, typeof P S2 S1 T.
\end{verbatim}

\heroADVISOR{} Looks good. Can you do the typing rule for the case statement?

\heroSTUDENT{} How does this look?

\begin{verbatim}
typeof (case_or_else Scrutinee Pattern Body Else) T' :-
  typeof Scrutinee T,
  typeof Pattern nil TS T,
  openmany Body (pfun xs body \ensuremath{\Rightarrow} assumemany typeof xs TS (typeof body T')),
  typeof Else T'.
\end{verbatim}

\heroADVISOR{} That's great! This was a little tricky, but still, not too bad.
Actually, I know of one thing that is surprisingly simple to do: the
evaluation rule. We just have to convert a pattern into a term, where we
replace the pattern variables with \emph{meta-level} unification
variables -- then we can just reuse meta-level unification to do the
actual pattern match!

\heroSTUDENT{} Oh, that would be nice. So not only do we get variable
substitutions for free, we also get unification for free in some cases!

\heroADVISOR{} Exactly. So something like this should work:

\begin{verbatim}
patt_to_term : [T T'] patt T T' \ensuremath{\to} term \ensuremath{\to} subst term T' \ensuremath{\to} subst term T \ensuremath{\to} prop.
patt_to_term patt_var X Subst (X :: Subst).
patt_to_term patt_wild _ Subst Subst.
patt_to_term patt_zero zero Subst Subst.
patt_to_term (patt_succ PN) (succ EN) Subst' Subst :- patt_to_term PN EN Subst' Subst.
\end{verbatim}

\heroSTUDENT{} I see, interesting! So in each rule we introduce the
unification variables that we need, like \texttt{X} for the variable
case, and store them in the substitution that we will use with the
pattern body.

\begin{scenecomment}
(Our heroes also write down the rules for multiple patterns and tuples, which are
available in the unabridged version of this story.)
\end{scenecomment}

\heroADVISOR{} We should be good to write the evaluation rule now.

\begin{verbatim}
eval (case_or_else Scrutinee Pattern Body Else) V :-
  patt_to_term Pattern TermWithUnifvars [] Unifvars,
  if (eq Scrutinee TermWithUnifvars)  (* reuse unification from the meta-language *)
  then (applymany Body Unifvars Body', eval Body' V)
  else (eval Else V).
\end{verbatim}

\heroSTUDENT{} I see! So, if meta-level unification is successful, we have a
match, and we substitute the instantiations we found for the pattern
variables into the body. But you are using if-then-else? We haven't used
that so far.

\heroADVISOR{} Oh yes, I forgot to mention that. It behaves as follows: when
there is at least one way to prove the condition, it proceeds to the
\texttt{then} branch, otherwise it goes to the \texttt{else} branch.
Pretty standard really. It is one thing that the Prolog cut statement,
\texttt{!}, is useful for, but cut introduces all sorts of trouble.
\citet{kiselyov05backtracking} is worth reading for alternatives to the
cut statement and the semantics of
\texttt{if}-\texttt{then}-\texttt{else} and \texttt{not} in logic
programming, and Makam follows that closely.

\heroSTUDENT{} Noted in my to-read list. But let us try pattern matching out!
How about predecessors for natural numbers? I'll write a query that
type-checks and evaluates a couple of cases.

\begin{verbatim}
(eq _PRED (lam _ (fun n \ensuremath{\Rightarrow} case_or_else n
  (patt_succ patt_var) (dbindnext (fun pred \ensuremath{\Rightarrow} dbindbase pred))
  zero)),
 typeof _PRED T,
 eval (app _PRED zero) PRED0, eval (app _PRED (succ (succ zero))) PRED2) ?
>> Yes:
>> T := arrow nat nat, PRED0 := zero, PRED2 := succ zero.
\end{verbatim}

\heroADVISOR{} Seems to be working fine!

\section{Where our heroes add parentheses and discover how to do
multiple
binding}\label{where-our-heroes-add-parentheses-and-discover-how-to-do-multiple-binding}

\heroSTUDENT{} Still, I feel like we've been playing to the strengths of
\lamprolog\ldots{} Yes, single-variable binding, substitutions and so on
work nicely, but how about any other form of binding? Say, binding
multiple variables at the same time? We are definitely going to need
that for the language we have in mind, and I remember that
\citet{keuchel2016needle} mention that HOAS encodings do not work for
such forms of binding.

\heroADVISOR{} I beg to differ. Let's try it out, let's try adding
multiple-argument functions for example -- I mean uncurried ones. Want
to give it at try?

\heroSTUDENT{} Let me see. Well, I want to write something like this, but I
know this is wrong.

\begin{verbatim}
lammany : (list term \ensuremath{\to} term) \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} Yes, that doesn't quite work. This would introduce a fresh
variable for \texttt{list}s, not a number of fresh variables for
\texttt{term}s. HOAS functions are parametric too, which means we cannot
even get to the potential elements of the fresh \texttt{list}.

\heroSTUDENT{} Right. So I don't know, instead we want to use a type that
stands for \texttt{term\ \ensuremath{\to}\ term},
\texttt{term\ \ensuremath{\to}\ term\ \ensuremath{\to}\ term}, and so on.
Can we write \texttt{term\ \ensuremath{\to}\ ...\ \ensuremath{\to}\ term}?

\heroADVISOR{} Well, not quite, but we have already defined something similar,
a type that roughly stands for \texttt{term\ *\ term},
\texttt{term\ *\ term\ *\ term}, we did not need anything special for
that\ldots{}

\heroSTUDENT{} You mean the \texttt{list} type?

\heroADVISOR{} Exactly. What do you think about this definition?

\begin{verbatim}
bindmanyterms : type.
bindnil : term \ensuremath{\to} bindmanyterms.
bindcons : (term \ensuremath{\to} bindmanyterms) \ensuremath{\to} bindmanyterms.
\end{verbatim}

\heroSTUDENT{} Hmm. That looks quite similar to lists, the parentheses in
\texttt{cons} are different. \texttt{nil} gets an extra \texttt{term}
argument too\ldots{}

\heroADVISOR{} Yes\ldots{} So what is happening here is that \texttt{bindcons}
takes a single argument, adding another binder; and \texttt{bindnil} is
when we get to the body and don't need any more binders, so we just need
the body.

\heroSTUDENT{} Oh so could we generalize their types? Maybe that will help me
get a better grasp of it. How is this?

\begin{verbatim}
bindmany : type \ensuremath{\to} type \ensuremath{\to} type.
bindbase : Body \ensuremath{\to} bindmany Variable Body.
bindnext : (Variable \ensuremath{\to} bindmany Variable Body) \ensuremath{\to} bindmany Variable Body.
\end{verbatim}

\heroADVISOR{} This looks great! Though let me say, I cheated a bit: in order
for the constructors to look nicer, we have allowed binding zero
variables. We could definitely disallow that by changing
\texttt{bindbase} to take a \texttt{Variable\ \ensuremath{\to}\ Body}
argument instead, but let's just go along with this, it will make all
our predicates simpler to write too.

\heroSTUDENT{} I see. That is quite an interesting datatype, is there some
reference about it?

\heroADVISOR{} Not that I know of -- though I think this is part of PL
folklore. After I started using this in Makam, I noticed similar
constructions in the wild, for example in MTac \citep{ziliani2013mtac},
for the parametric HOAS implementation of telescopes.

\heroSTUDENT{} Interesting. So how do we work with \texttt{bindmany}? I know
we can now define \texttt{lammany} as follows, but how about the typing
rules?

\begin{verbatim}
lammany : bindmany term term \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} Well, for the built-in single binding type, we used three
built-in operations:

\begin{itemize}
\tightlist
\item
  variable substitution, encoded through HOAS function application
\item
  introducing a fresh variable, through the predicate form
  \texttt{x:term\ \ensuremath{\to}\ ...}
\item
  introducing a new assumption, through the predicate form
  \texttt{P\ \ensuremath{\to}\ ...}
\end{itemize}

\heroSTUDENT{} So we should add three operations for \texttt{bindmany} that
correspond to those, right?

\heroADVISOR{} Correct, and they will be predicates, since that's the only
kind of computation we can define in \lamprolog{}. So let's first do the
predicate that generalizes application:

\begin{verbatim}
applymany : bindmany A B \ensuremath{\to} list A \ensuremath{\to} B \ensuremath{\to} prop.
applymany (bindbase Body) [] Body.
applymany (bindnext F) (HD :: TL) Body :-
  applymany (F HD) TL Body.
\end{verbatim}

\heroSTUDENT{} I see, so given a \texttt{bindmany} and a substitution for the
variables, perform simultaneous substitution to get the body.

\heroADVISOR{} Right. And a predicate for introducing multiple variables at
once. Then you try doing multiple assumptions.

\begin{verbatim}
intromany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} prop) \ensuremath{\to} prop.
intromany (bindbase _) P :- P [].
intromany (bindnext F) P :-
  (x:A \ensuremath{\to} intromany (F x) (fun tl \ensuremath{\Rightarrow} P (x :: tl))).
\end{verbatim}

\heroSTUDENT{} Let me see. So pattern match on the two cases, introduce an
extra assumption in the \texttt{bindnext} case. How does this look?

\begin{verbatim}
assumemany : (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} list A \ensuremath{\to} list B \ensuremath{\to} prop \ensuremath{\to} prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y \ensuremath{\to} assumemany P XS YS Q).
\end{verbatim}

\heroADVISOR{} That looks good. Maybe one thing to note is that this last rule
might not work in other \lamprolog implementations, as it introduces an
assumption for a predicate that is not known statically, and that is
usually not allowed. That's why I said we should use Makam.

\heroSTUDENT{} Is that a limitation that has to do with the correspondence of
\lamprolog to logic?

\heroADVISOR{} Not really, I believe that is because of implementation
concerns mostly -- it would significantly complicate VMs for the
language. But Makam is interpreted, so it sidesteps that.

\heroSTUDENT{} Interesting. So let me try doing the typing rule now. I'll add
a type for multiple argument functions. Would this work?

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.
typeof (lammany F) (arrowmany TS T') :-
  intromany F (fun xs \ensuremath{\Rightarrow}
    applymany F xs Body,
    assumemany typeof xs TS (typeof Body T')).
\end{verbatim}

\heroADVISOR{} Almost. There is an issue here: the unification variable
\texttt{Body} cannot capture the free variables \texttt{xs} that get
introduced later. Unification variables are allowed to capture all the
free variables in scope at the point where they are introduced. By
default, they get introduced when the rule fires, but here we need to
explicitly say that \texttt{Body} should be introduced when
\texttt{intromany} uses its predicate argument; Makam uses square
bracket notation for that. Oh, and a Makam idiosyncrasy: the parser
isn't clever enough to tell that the predicate argument to
\texttt{intromany} is, in fact, a predicate, so we can't use the normal
predicate syntax for it. There is the syntactic form \texttt{pfun} for
anonymous predicates, save for predicate syntax, it's entirely identical
to \texttt{fun}. So:

\begin{verbatim}
typeof (lammany F) (arrowmany TS T') :-
  intromany F (pfun xs \ensuremath{\Rightarrow} (
    [Body]
      applymany F xs Body,
      assumemany typeof xs TS (typeof Body T'))).
\end{verbatim}

\heroSTUDENT{} Would it make sense to combine \texttt{intromany} and
\texttt{appmany} into one predicate, like this, since we will probably
always need both the variables and the body of a \texttt{bindmany}?

\begin{verbatim}
openmany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
openmany F P :-
  intromany F (pfun xs \ensuremath{\Rightarrow} [Body] applymany F xs Body, P xs Body).
\end{verbatim}

\heroADVISOR{} Yes, that predicate turns out to be quite useful. Let's try out
a query now!

\begin{verbatim}
typeof (lammany (bindnext (fun x \ensuremath{\Rightarrow} bindnext (fun y \ensuremath{\Rightarrow} bindbase (tuple [y, x]))))) T ?
>> Yes:
>> T := arrowmany [T1, T2] (product [T2, T1])
\end{verbatim}

\heroSTUDENT{} Great, I think I got the hang of this. We could definitely add
a multiple-argument application construct \texttt{appmany} or define the
rules for \texttt{eval} for these. But that would be easy, we can do
that later. Something that worries me though -- all these fancy
higher-order abstract binders, how do we \ldots{} make them concrete?
Say, how do we print them?

\heroADVISOR{} That's actually quite easy. We just add a concrete name to
them. A plain old \texttt{string}. Our typing rules etc. do not care
about it, but we could use it for parsing concrete syntax into our
abstract binding syntax, or for pretty-printing\ldots{} Let's not get
into that for the time being, but let's just say that we could have
defined \texttt{bindnext} with an extra \texttt{string} argument; and
then \texttt{intromany} and friends would just ignore it.

\begin{verbatim}
bindnext : string \ensuremath{\to} (Variable \ensuremath{\to} bindmany Variable Body) \ensuremath{\to} bindmany Variable Body.
\end{verbatim}

\heroSTUDENT{} Interesting, I would like to see more about this, but maybe
some other time. I thought of another thing that could be challenging:
mutually recursive \texttt{let\ rec}s?

\heroADVISOR{} Sure -- how about this?

\begin{verbatim}
letrec : bindmany term (list term) \ensuremath{\to} bindmany term term \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Bind many terms into a list of terms, then bind other terms
into a term\ldots{} Is the first list the definitions and the second
list the body?

\heroADVISOR{} Yes -- just to make this clear, for this expression \ldots{}

\begin{verbatim}
let rec f = f_def and g = g_def in body
\end{verbatim}

\heroSTUDENT{} \ldots{} we would write something like this:

\begin{verbatim}
letrec (bindnext (fun f \ensuremath{\Rightarrow} bindnext (fun g \ensuremath{\Rightarrow} bindbase ([f_def, g_def]))))
       (bindnext (fun f \ensuremath{\Rightarrow} bindnext (fun g \ensuremath{\Rightarrow} bindbase body)))
\end{verbatim}

\heroADVISOR{} Yes, and we need to be careful so that the number of binders
matches between the definitions and the body, and also that we have as
many definitions as we have binders. We can go ahead and encode that in
our typing rules\ldots{}

\heroSTUDENT{} Wait. I let you get away before with the zero binders in
\texttt{bindmany}, this is pushing it a little bit. This doesn't sound
like an accurate encoding.

\heroADVISOR{} You're right, but we would need some sort of dependency to
enforce those kinds of limitations\ldots{} and \lamprolog does not have
dependent types.

\heroSTUDENT{} Well neither did Haskell a few years back, people still got
functional pearls published though?

\heroADVISOR{} That is a weird thing to say.

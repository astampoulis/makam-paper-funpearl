The type system of \ensuremath{\lambda}Prolog can be viewed as a particular subset of
System F\(_\ensuremath{\omega}\): namely, it is the simply typed lambda calculus extended
with prenex polymorphism and simple type constructors of the form
\texttt{type\ \ensuremath{\to}\ type\ \ensuremath{\to}\ ...\ \ensuremath{\to}\ type}.
(As an aside, \texttt{prop} can be viewed as a separate sort, but we
take the view that it is just a distinguished extensible type.)

As is well-known from Haskell even before the addition of kind
definitions, type promotion, and type-in-type, this subset of System
F\(_\ensuremath{\omega}\) is enough to model some form of dependency. For example, we can
introduce two types for modelling natural numbers, then define vectors
as a GADT using them:

\begin{verbatim}
natZ : type.
natS : type \ensuremath{\to} type.

vector : type \ensuremath{\to} type \ensuremath{\to} type.
vnil : vector natZ A.
vcons : A \ensuremath{\to} vector N A \ensuremath{\to} vector (natS N) A.
\end{verbatim}

In fact, \ensuremath{\lambda}Prolog naturally supports pattern-matching over such
constructors as well, through \emph{ad-hoc polymorphism}, where
polymorphic type variables are allowed to be instantiated at
\emph{runtime} rather than at type-checking time. The mechanism through
which ad-hoc polymorphism works in \ensuremath{\lambda}Prolog is simple: before performing
unification at the term-level, we perform unification at the type level
first, therefore further determining any uninstantiated type variables.
Therefore, when we check to see whether the current goal matches the
premise of a rule, type unification can force us to distinguish between
different types. Based on these, the standard example of \texttt{map}
for vectors is as follows:

\begin{verbatim}
vmap : [N] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} vector N A \ensuremath{\to} vector N B \ensuremath{\to} prop.
vmap P vnil vnil.
vmap P (vcons X XS) (vcons Y YS) :- P X Y, vmap P XS YS.
\end{verbatim}

The notation \texttt{{[}N{]}} in the type of \texttt{vmap} means that
the type argument \texttt{N} is ad-hoc/not-parametric. Non-specified
type arguments are parametric by default, so as to match standard
practice in languages like ML and Haskell, and to catch type errors that
allowing unqualified ad-hoc polymorphism would permit. For example,
consider the following erroneous definition for \texttt{fold}, where the
arguments for \texttt{P} in the \texttt{cons} case are flipped.

\begin{verbatim}
foldl : (B \ensuremath{\to} A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} list A \ensuremath{\to} B \ensuremath{\to} prop.
foldl P S nil S.
foldl P S (cons HD TL) S'' <- P HD S S', foldl P S' TL S''.
\end{verbatim}

If ad-hoc polymorphism is allowed for \texttt{A} and \texttt{B}, the
definition is well-typed. However, the erroneous call to \texttt{P}
forces the types \texttt{A} and \texttt{B} to be unified, and therefore
the \texttt{fold} predicate is unnecessarily restricted to only work
when the two types are the same. Having to specify ad-hoc polymorphism
explicitly helps us avoid such mistakes.

Though this support for ad-hoc polymorphism was part of the original
\ensuremath{\lambda}Prolog design, we have not found extensive coverage of its implications
in the literature. Furthermore, it is not supported well by standard
implementations of \ensuremath{\lambda}Prolog (like Teyjus), which was one of the reasons
that prompted us to work on Makam.

Armed with GADTs of this form, we can now introduce dependently typed
binding forms, where the number of variables that are being bound is
reflected in the type. One approach uses a type of the form
\texttt{dbind\ A\ N\ B}, standing for a dependently typed binding of
\texttt{N} fresh variables of type \texttt{A} into a body of type
\texttt{B}. \texttt{N} will be instantiated with \texttt{natZ} and
\texttt{natS} as above.

\begin{verbatim}
dbind : type \ensuremath{\to} type \ensuremath{\to} type \ensuremath{\to} type. 

dbindbase : B \ensuremath{\to} dbind A natZ B.
dbindnext : (A \ensuremath{\to} dbind A N B) \ensuremath{\to} dbind A (natS N) B.
\end{verbatim}

Another possibility, avoiding the need for introducing type-level
natural numbers, is to use a more standard type as the dependent
parameter: the type of tuples that would serve as substitutions for the
introduced variables. The type would then become:

\begin{verbatim}
dbind : type \ensuremath{\to} type \ensuremath{\to} type \ensuremath{\to} type.

dbindbase : B \ensuremath{\to} dbind A unit B.
dbindnext : (A \ensuremath{\to} dbind A T B) \ensuremath{\to} dbind A (A * T) B.
\end{verbatim}

The definitions for helper predicates, such as \texttt{intromany},
\texttt{applymany}, etc., follow the case for \texttt{bindmany} closely,
only with more precise types. We first define a helper type
\texttt{subst\ A\ T} that is equivalent to the type of tuples \texttt{T}
we expect, which is not strictly necessary but allows for more precise
types:

\begin{verbatim}
subst : type \ensuremath{\to} type \ensuremath{\to} type.
nil : subst A unit.
cons : A \ensuremath{\to} subst A T \ensuremath{\to} subst A (A * T).
\end{verbatim}

The predicates are now defined as follows. First, their types are:

\begin{verbatim}
intromany : [T] dbind A T B \ensuremath{\to} (subst A T \ensuremath{\to} prop) \ensuremath{\to} prop.
applymany : [T] dbind A T B \ensuremath{\to} subst A T \ensuremath{\to} B \ensuremath{\to} prop.
openmany : [T] dbind A T B \ensuremath{\to} (subst A T \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
\end{verbatim}

Note that we are reusing the same predicate names as before. Makam
allows overloading for all variable names; expected types are taken into
account for resolving variables and disambiguating between them, as has
been long known to be possible in the bi-directional type-checking
literature. Type ascription is used when variable resolution is
ambiguous. We also sometimes avoid overloading for constructors; having
unambiguous types for constructors means that they can be used to
resolve ambiguity between overloaded predicates easily. However, here we
reuse the \texttt{nil} and \texttt{cons} constructors for \texttt{subst}
so that we can use the sugared form for list-like datatypes (using
\texttt{{[}{]}} and \texttt{::}).

\begin{verbatim}
intromany (dbindbase F) P :- P nil.
intromany (dbindnext F) P :-
  (x:A \ensuremath{\to} intromany (F x) (pfun t \ensuremath{\Rightarrow} P (x :: t))).

applymany (dbindbase Body) [] Body.
applymany (dbindnext F) (X :: XS) Body :- applymany (F X) XS Body.

openmany F P :-
  intromany F (pfun xs \ensuremath{\Rightarrow} [Body] applymany F xs Body, P xs Body).
\end{verbatim}

Also, we define predicates analogous to \texttt{map} and
\texttt{assumemany} for the \texttt{subst} type:

\begin{verbatim}
assumemany : [T T'] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} subst A T \ensuremath{\to} subst B T' \ensuremath{\to} prop \ensuremath{\to} prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y \ensuremath{\to} assumemany P XS YS Q).

map : [T T'] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} subst A T \ensuremath{\to} subst B T' \ensuremath{\to} prop.
map P [] [].
map P (X :: XS) (Y :: YS) :- P X Y, map P XS YS.
\end{verbatim}

(Here we have not captured the relationship between the type of tuples
\texttt{T} and \texttt{T\textquotesingle{}} precisely, namely that one
structurally matches the other with \texttt{A}s replaced by \texttt{B}s.
With a more complicated presentation, we could capture it by adding
another argument of a dependent type.)

Using this type, we can define \texttt{letrec} as follows:

\begin{verbatim}
letrec : dbind term T (subst term T) \ensuremath{\to} dbind term T term \ensuremath{\to} term.
\end{verbatim}

This encoding captures the binding structure of the construct precisely:
we need the same number of definitions as the number of variables we
introduce, and the body of the construct needs exactly the same number
of variables bound.

The typing rule is entirely similar to the one we had previously:

\begin{verbatim}
typeof (letrec Defs Body) T' :-
  openmany Defs (pfun xs defs \ensuremath{\Rightarrow}
    assumemany typeof xs TS (map typeof defs TS)
  ),
  openmany Body (pfun xs body \ensuremath{\Rightarrow}
    assumemany typeof xs TS (typeof body T')
  ).
\end{verbatim}

\subsection{Patterns}\label{patterns}

We can also use the same `dependency' trick for other, more complicated
forms of binding. One such example, which we sketch below, is linear
ordered binding as in the case of patterns. The point is that having
explicit support in our metalanguage only for single-variable binding,
as is standard in HOAS, together with the two kinds of polymorphism we
have shown, is enough. Using them, we can encode complicated binding
forms, that often require explicit support in other meta-linguistic
settings (e.g.~Needle + Knot, Unbound, etc.)

At the top level, a single type argument is needed for patterns,
representing the list of variables that it uses in the order that they
are used. Each variable can only be used once, so at the level of
patterns, there is not really a notion of binding: pattern variables are
``introduced'' at their point of use. However, the list of variables
that we build up can be reused in order to be actually bound into a term
-- e.g.~the body of a pattern-matching branch.

(Single-variable binding is really a way to introduce a ``point'' in an
AST that we can ``refer back to'' from its children; or the means to
introduce sharing in the notion of ASTs, allowing to refer to the same
``thing'' a number of times. There is no sharing going on inside
patterns, though; hence no binding constructs are needed for encoding
the patterns themselves.)

Each sub-pattern that makes up a pattern needs to depend on two
arguments, in order to capture the linearity -- the fact that variables
``go away'' after their first uses. The first argument represents all
the variables that can be used, initially matching the type argument of
the top-level pattern; the second argument represents the variables that
``remain'' to be used after this sub-pattern is traversed. We use
``initially'' and ``after'' to refer to the order of visiting the
sub-patterns in a structural, depth-first traversal of the pattern. The
``difference'' between the types corresponds to the variables that each
particular sub-pattern uses.

To make the presentation cleaner, we will introduce a single type for
patterns that has both arguments, with the requirement that for
top-level arguments, no variables remain.

\begin{verbatim}
patt : type \ensuremath{\to} type \ensuremath{\to} type.
\end{verbatim}

(Probably hidden: add natural numbers so that we can have a simple
example of patterns.)

\begin{verbatim}
nat : typ.
zero : term.
succ : term \ensuremath{\to} term.
typeof zero nat.
typeof (succ N) nat :- typeof N nat.
eval zero zero.
eval (succ E) (succ V) :- eval E V.
\end{verbatim}

The pattern for zero does not use any variables; the pattern
\texttt{succ\ P} for successor uses the same variables that \texttt{P}
does.

\begin{verbatim}
patt_zero : patt T T.
patt_succ : patt T T' \ensuremath{\to} patt T T'.
\end{verbatim}

A single pattern variable declares/uses exactly itself.

\begin{verbatim}
patt_var : patt (term * T) T.
\end{verbatim}

A wildcard pattern does not use any variables.

\begin{verbatim}
patt_wild : patt T T.
\end{verbatim}

n-ary tuples require a type for pattern lists:

\begin{verbatim}
pattlist : type \ensuremath{\to} type \ensuremath{\to} type.
patt_tuple : pattlist T T' \ensuremath{\to} patt T T'.

nil : pattlist T T.
cons : patt T1 T2 \ensuremath{\to} pattlist T2 T3 \ensuremath{\to} pattlist T1 T3.
\end{verbatim}

We can now encode a single-branch ``case-or-else'' statement as follows:

\begin{verbatim}
case_or_else : term \ensuremath{\to} patt T unit \ensuremath{\to} dbind term T term \ensuremath{\to} term \ensuremath{\to} term.
\end{verbatim}

The first argument is the scrutinee; the second is the pattern; the
third is the branch body, where we bind the same number of variables as
the ones used in the pattern; and the last argument is the \texttt{else}
case.

The typing relation for patterns is defined as follows: given a pattern
and a list of types for the variables that remain after the pattern,
yield a list of types for all the variables that are available, plus the
type of the pattern.

\begin{verbatim}
typeof : [T T' Ttyp T'typ] patt T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} typ \ensuremath{\to} prop.

typeof patt_var S' (cons T S') T.
typeof patt_wild S S T.
typeof patt_zero S S nat.
typeof (patt_succ P) S' S nat :-
  typeof P S' S nat.

typeof :
  [T T' Ttyp T'typ] pattlist T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} list typ \ensuremath{\to} prop.

typeof (patt_tuple PS) S' S (product TS) :-
  typeof PS S' S TS.

typeof [] S S [].
typeof (P :: PS) S3 S1 (T :: TS) :-
  typeof PS S3 S2 TS, typeof P S2 S1 T.

typeof (case_or_else Scrutinee Pattern Body Else) T' :-
  typeof Scrutinee T,
  typeof Pattern nil TS T,
  openmany Body (pfun xs body \ensuremath{\Rightarrow}
     (assumemany typeof xs TS (typeof body T'))
  ),
  typeof Else T'.
\end{verbatim}

In order to define evaluation rules, we could define a predicate that
models unification between patterns and terms. However, we can do better
than that: we can re-use the existing support for unification from the
metalanguage! In that case, all we need is a way to convert a pattern
into a term, with pattern variables replaced by \emph{meta-level
metavariables}. The metavariables are introduced at each conversion rule
as needed, and will get instantiated to the right terms if unification
with the scrutinee succeeds.

\begin{verbatim}
patt_to_term : [T T'] patt T T' \ensuremath{\to} term \ensuremath{\to} subst term T' \ensuremath{\to} subst term T \ensuremath{\to} prop.
patt_to_term patt_var X Subst (X :: Subst).
patt_to_term patt_wild _ Subst Subst.
patt_to_term patt_zero zero Subst Subst.
patt_to_term (patt_succ PN) (succ EN) Subst' Subst :- patt_to_term PN EN Subst' Subst.

pattlist_to_termlist : [T T'] pattlist T T' \ensuremath{\to} list term \ensuremath{\to} subst term T' \ensuremath{\to} subst term T \ensuremath{\to} prop.

patt_to_term (patt_tuple PS) (tuple ES) Subst' Subst :-
  pattlist_to_termlist PS ES Subst' Subst.

pattlist_to_termlist [] [] Subst Subst.
pattlist_to_termlist (P :: PS) (T :: TS) Subst3 Subst1 :-
  pattlist_to_termlist PS TS Subst3 Subst2,
  patt_to_term P T Subst2 Subst1.

eval (case_or_else Scrutinee Pattern Body Else) V :-
  patt_to_term Pattern TermWithUnifvars [] Unifvars,
  if (eq Scrutinee TermWithUnifvars)  (* reuse unification from the meta-language *)
  then (applymany Body Unifvars Body', eval Body' V)
  else (eval Else V).
\end{verbatim}

Two new things here: if-then-else has the semantics described in the
LogicT monad paper. \texttt{eq} is a predicate that forces its arguments
to be unified, defined simply as:

\begin{verbatim}
eq : A \ensuremath{\to} A \ensuremath{\to} prop.
eq X X.
\end{verbatim}

Here is an example of pattern matching: predecessor for natural numbers.

\begin{verbatim}
(eq _PRED 
  (lam _ (fun n \ensuremath{\Rightarrow} 
    case_or_else n
      (patt_succ patt_var) (dbindnext (fun pred \ensuremath{\Rightarrow} dbindbase pred))
      zero
      )),
 typeof _PRED T,
 eval (app _PRED zero) PRED_OF_ZERO,
 eval (app _PRED (succ (succ zero))) PRED_OF_TWO) ?
>> Yes:
>> T := arrow nat nat
>> PRED_OF_ZERO := zero
>> PRED_OF_TWO := succ zero
\end{verbatim}

%use "03-bindmany".
tests: testsuite. %testsuite tests.

zero : type. succ : type -> type.
vector : type -> type -> type.
vnil : vector A zero.
vcons : A -> vector A N -> vector A (succ N).

vmap : [N] (A -> B -> prop) -> vector A N -> vector B N -> prop.
vmap P vnil vnil.
vmap P (vcons X XS) (vcons Y YS) :- P X Y, vmap P XS YS.

vbindmany : (Var: type) (N: type) (Body: type) -> type.
vbody : Body -> vbindmany Var zero Body.
vbind : (Var -> vbindmany Var N Body) -> vbindmany Var (succ N) Body.

vopenmany : [N] vbindmany Var N Body -> (vector Var N -> Body -> prop) -> prop.
vopenmany (vbody Body) Q :- Q vnil Body.
vopenmany (vbind F) Q :-
  (x:A -> vopenmany (F x) (fun xs => Q (vcons x xs))).

vletrec : vbindmany term N (vector term N * term) -> term.

vapplymany : [N] vbindmany Var N Body -> vector Var N -> Body -> prop.
vapplymany (vbody Body) vnil Body.
vapplymany (vbind F) (vcons X XS) Body :- vapplymany (F X) XS Body.

vassumemany : [N] (A -> B -> prop) -> vector A N -> vector B N -> prop -> prop.
vassumemany P vnil vnil Q :- Q.
vassumemany P (vcons X XS) (vcons Y YS) Q :- (P X Y -> vassumemany P XS YS Q).

typeof (vletrec XS_DefsBody) T' :-
  vopenmany XS_DefsBody (pfun xs (Defs, Body) =>
    vassumemany typeof xs TS (vmap typeof Defs TS),
    vassumemany typeof xs TS (typeof Body T')).

typeof (vletrec (vbind (fun f => vbody (vcons (lam T (fun x => app f (app f x))) vnil, f)))) T' ?
>> Yes:
>> T' := arrow T T,
>> T := T.

dbind : type -> type -> type -> type.
dbindbase : B -> dbind A unit B.
dbindnext : (A -> dbind A T B) -> dbind A (A * T) B.

subst : type -> type -> type.
nil : subst A unit.  cons : A -> subst A T -> subst A (A * T).

intromany : [T] dbind A T B -> (subst A T -> prop) -> prop.
applymany : [T] dbind A T B -> subst A T -> B -> prop.
openmany : [T] dbind A T B -> (subst A T -> B -> prop) -> prop.
assumemany : [T T'] (A -> B -> prop) -> subst A T -> subst B T' -> prop -> prop.
map : [T T'] (A -> B -> prop) -> subst A T -> subst B T' -> prop.

intromany (dbindbase F) P :- P [].
intromany (dbindnext F) P :- (x:A -> intromany (F x) (pfun t => P (x :: t))).

applymany (dbindbase Body) [] Body.
applymany (dbindnext F) (X :: XS) Body :- applymany (F X) XS Body.

openmany F P :-
  intromany F (pfun xs => [Body] applymany F xs Body, P xs Body).

assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y -> assumemany P XS YS Q).

map P [] [].
map P (X :: XS) (Y :: YS) :- P X Y, map P XS YS.

letrec : dbind term T (subst term T * term) -> term.
typeof (letrec XS_DefsBody) T' :-
  openmany XS_DefsBody (pfun xs defsbody => [Defs Body]
    eq defsbody (Defs, Body),
    assumemany typeof xs TS (map typeof Defs TS),
    assumemany typeof xs TS (typeof Body T')).


\section{Where our heroes tackle dependencies, contexts, and a new level
of
meta}\label{where-our-heroes-tackle-dependencies-contexts-and-a-new-level-of-meta}

\heroSTUDENT{} I'm fairly confident by now that Makam should be able to handle
the research idea we want to try out. Shall we get to it?

\heroADVISOR{} Yes, it is time. So, what we are aiming to do, is add a
facility for type-safe, heterogeneous meta-programming to our object
language, similar to MetaHaskell \citep{mainland2012explicitly}. This
way we can manipulate the terms of a separate object language in a
type-safe manner.

\heroSTUDENT{} Exactly. We'd like our object language to be a formal logic, so
our language will be similar to Beluga \citep{pientka2010beluga} or
VeriML \citep{stampoulis2013veriml}. We'll have to be able to pattern
match over the terms of the object language, too, so they are runtime
entities too\ldots{}. But we don't need to do all of that, let's just do
a basic version for now, and I can do the rest on my own.

\heroADVISOR{} Sounds good. So, I think the fragment we should do is this: we
will have dependent functions over a distinguished language of
\emph{dependent indices}. We need the dependency so that, for example,
we can take an object-level type as an argument, and return an
object-level term that uses that type.

\heroSTUDENT{} Exactly. Dependent products should be similar, but we can skip
them for now, and just add a way to return an object-level term from the
meta-level terms.

\heroADVISOR{} Good idea. We are getting into many levels of meta -- there's
the meta-language we're using, Makam; there's the object language we are
encoding, which is a meta-language in itself, let's call that
Heterogeneous Meta ML Light (HMML?); and there's the ``object-object''
language that HMML is manipulating. And let's keep that last one simple:
the simply typed lambda calculus (STLC).

\heroSTUDENT{} Great. So, our dependent indices will be the types and terms of
STLC -- actually, the open terms of STLC.

\heroADVISOR{} It's a plan. So, let's get to it. Let's first add distinguished
sorts for dependent indices, and dependent classifiers -- we'll use
those to type-check the indices, using an appropriate predicate. Let's
also have a distinguished type for \emph{dependent variables}, that is,
variables of dependent indices; and a way to substitute such a variable
for an object.

\begin{verbatim}
depindex, depclassifier, depvar : type.
depclassify : depindex \ensuremath{\to} depclassifier \ensuremath{\to} prop.
depclassify : depvar \ensuremath{\to} depclassifier \ensuremath{\to} prop.
depsubst : [A] (depvar \ensuremath{\to} A) \ensuremath{\to} depindex \ensuremath{\to} A \ensuremath{\to} prop.
\end{verbatim}

\newcommand\dep[1]{\ensuremath{#1_{\text{d}}}}
\newcommand\lift[1]{\ensuremath{\langle#1\rangle}}

\heroSTUDENT{} Right, we might need to treat variables specially, so it's good
that they're a different type. And let's assume that classifiers are
well-formed by construction.

\heroADVISOR{} Now, we have a few typing rules to add. I'll use
``\(\dep{\cdot}\)'' to signify things that have to do with the dependent
indices.

\vspace{-1em}\begin{mathpar}
\small
\inferrule{\dep{\Psi} \dep{\vdash} \dep{c} : \dep{i}}
          {\Gamma; \dep{\Psi} \vdash \lift{\dep{c}} : \lift{\dep{i}}}

\inferrule{\Gamma; \dep{\Psi}, \; \dep{v} : \dep{c} \vdash e : \tau}
          {\Gamma; \dep{\Psi} \vdash \Lambda \dep{v} : \dep{c}.e : \Pi \dep{v} : \dep{c}.\tau}

\inferrule{\Gamma; \dep{\Psi} \vdash e : \Pi \dep{v} : \dep{c}.\tau \\ \dep{\Psi} \dep{\vdash} \dep{i} : \dep{c}}
          {\Gamma; \dep{\Psi} \vdash e @ \dep{c} : \dep{\text{subst}}(\tau, [\dep{i}/\dep[v]])}
\end{mathpar}

\heroSTUDENT{} Those are very easy to transcribe to Makam.

\begin{verbatim}
lamdep : depclassifier \ensuremath{\to} (depvar \ensuremath{\to} term) \ensuremath{\to} term.
appdep : term \ensuremath{\to} depindex \ensuremath{\to} term.
liftdep : depindex \ensuremath{\to} term. liftdep : depclassifier \ensuremath{\to} typ.
pidep : depclassifier \ensuremath{\to} (depvar \ensuremath{\to} typ) \ensuremath{\to} typ.

typeof (lamdep C EF) (pidep C TF) :-
  (v:depvar \ensuremath{\to} depclassify v C \ensuremath{\to} typeof (EF v) (TF v)).
typeof (appdep E I) T' :- typeof E (pidep C TF), depclassify I C, depsubst TF I T'.
typeof (liftdep I) (liftdep C) :- depclassify I C.
\end{verbatim}

\heroADVISOR{} Great. Just wanted to say, this framework is quite general. We
could instantiate dependent indices with a language of natural numbers,
equality predicates, and equality proofs; this would be quite similar to
the Dependent ML formulation of \citet{licata2005formulation}. But let's
go back to what we're trying to do. I'll add the object language in a
separate namespace prefix, and I'll just copy-paste our STLC code from
earlier on.

\begin{verbatim}
%extend object.
term : type. typ : type. typeof : term \ensuremath{\to} typ \ensuremath{\to} prop.
...
%end.
\end{verbatim}

\heroSTUDENT{} Great! I'll make these into dependent indices now, including
both types and terms.

\begin{verbatim}
iterm : object.term \ensuremath{\to} depindex.     ityp : object.typ \ensuremath{\to} depindex.
ctyp : object.typ \ensuremath{\to} depclassifier.  cext : depclassifier.

depclassify (iterm E) (ctyp T) :- object.typeof E T.
depclassify (ityp T) cext :- object.wftyp T.
\end{verbatim}

\heroADVISOR{} Right, we'll need to check that types are well-formed, too.
Right now, they are all well-formed by construction, but let's prepare
for any additions, by setting up a structurally recursive predicate:

\begin{verbatim}
%extend object.
wftyp : typ \ensuremath{\to} prop. wftyp_cases, wftyp_aux : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
wftyp T :- wftyp_aux T T.
wftyp_aux T T :-
  if (wftyp_cases T T) then success else (structural_recursion wftyp_aux T T).
%end.
\end{verbatim}

\heroSTUDENT{} I see -- your structural recursion just needs to do a visit, it
does not need to produce an output; hence the repeat of the same
\texttt{typ} argument. Let's prepare for substitutions too.

\begin{verbatim}
depsubst_aux, depsubst_cases : [A] depvar \ensuremath{\to} depindex \ensuremath{\to} A \ensuremath{\to} A \ensuremath{\to} prop.
depsubst F I Res :- (v:depvar \ensuremath{\to} depsubst_aux v I (F v) Res).
depsubst_aux Var Replace Where Result :-
  if (depsubst_cases Var Replace Where Result)
  then (success)
  else (structural_recursion (depsubst_aux Var Replace) Where Result).
\end{verbatim}

\heroADVISOR{} Great! We only have one thing missing: we need to close the
loop, being able to refer to dependent variables from within
object-level terms and types. By the way, we are very much following the
construction in \citet{stampoulis2013veriml}.

\heroSTUDENT{} I got this.

\begin{verbatim}
%extend object.
varterm : depvar \ensuremath{\to} term.  vartyp : depvar \ensuremath{\to} typ.

typeof (varterm V) T :- depclassify V (ctyp T).
wftyp_cases (vartyp V) (vartyp V) :- depclassify T cext.
%end.

depsubst_cases Var (iterm Replace) (object.varterm Var) Replace.
depsubst_cases Var (ityp Replace)  (object.vartyp Var)  Replace.
\end{verbatim}

\heroADVISOR{} This is exciting, let me try this out! I'll do a function that
takes an object-level type and returns the object-level identity
function for it.

\begin{verbatim}
typeof (lamdep cext (fun t \ensuremath{\Rightarrow}
         (liftdep (iterm (object.lam (object.vartyp t) (fun x \ensuremath{\Rightarrow} x)))))) T ?
>> Yes!!!!!
>> T := pidep cext (fun t \ensuremath{\Rightarrow}
>>        liftdep (ctyp (object.arrow (object.vartyp t) (object.vartyp t))))
\end{verbatim}

\heroSTUDENT{} Wow, even the Makam REPL is excited!

\heroADVISOR{} Wait until it sees what we have in store for it next: open STLC
terms in our indices!

\heroSTUDENT{} Good thing I've printed out the contextual types paper by
\citet{nanevski2008contextual}. (\ldots{}) OK, so it says here that we
can use contextual types to record at the type level, the context that
open terms depend on. So let's say, an open \texttt{object.term} of type
\(\tau\) that mentions variables of a \(\Phi\) context would have a
contextual type of the form \([\Phi] \tau\). This is some sort of modal
typing, with a precise context.

\heroADVISOR{}

We can also handle the case of non-closed terms, using contextual types:

\begin{verbatim}
%extend object.
subst : type \ensuremath{\to} type.
subst : list A \ensuremath{\to} subst A.

ctx : type \ensuremath{\to} type.
ctx : subst typ \ensuremath{\to} bindmany term A \ensuremath{\to} ctx A.

openctx : ctx A \ensuremath{\to} (subst term \ensuremath{\to} subst typ \ensuremath{\to} A \ensuremath{\to} prop) \ensuremath{\to} prop.
applyctx : ctx A \ensuremath{\to} subst term \ensuremath{\to} A \ensuremath{\to} prop.

openctx (ctx Types Binds) P :-
  openmany Binds (pfun vars body \ensuremath{\Rightarrow}
    P (subst vars) Types body
  ).

applyctx (ctx _ Binds) (subst Args) Result :-
  applymany Binds Args Result.

map : (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} subst A \ensuremath{\to} subst B \ensuremath{\to} prop.
map P (subst L) (subst L') :- map P L L'.
%end.

openterm : object.ctx object.term \ensuremath{\to} depindex.
ctxtyp : object.subst object.typ \ensuremath{\to} object.typ \ensuremath{\to} depclassifier.

depclassify (openterm CtxE) (ctxtyp Typs T) :-
  object.openctx CtxE (pfun vars typs e \ensuremath{\Rightarrow} [Units]
    object.map (pfun t u \ensuremath{\Rightarrow} object.wftyp t) typs (Units : object.subst unit),
    object.map eq typs Typs,
    object.typeof e T).
\end{verbatim}

And one last step: reify open terms back into the language:

\begin{verbatim}
%extend object.
metaterm : depindex \ensuremath{\to} subst term \ensuremath{\to} term.

typeof (metaterm E ES) T :-
  refl.isnvar E,
  depclassify E (ctxtyp Typs T),
  object.map object.typeof ES Typs.
%end.

depsubst_cases Var (openterm CtxE) (object.metaterm Var Subst) Result :-
  object.applyctx CtxE Subst E,
  depsubst_aux Var (openterm CtxE) E Result.
\end{verbatim}

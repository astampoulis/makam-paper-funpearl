(*
# Where our heroes get the easy stuff out of the way

HAGOP. OK, let's just start with the simply typed lambda calculus to see how this
works. Let's define just the basics, application, lambda abstraction and the arrow type.

ROZA. Right. We will first need to define the two meta-types for these two sorts:

*)

term : type.
typ : type.

(*

HAGOP. Oh, so `type` is the reserved keyword for the meta-level kind of types, and we'll
use `typ` for our object-level types?

ROZA. Exactly. And let's do the easy constructors first:

*)

app : term -> term -> term.
arrow : typ -> typ -> typ.

(*

HAGOP. So we add constructors to a type at any point, we do not list them out when we
define it like in Haskell. But how about lambdas? I have heard that \lamprolog supports
higher-order abstract syntax, which should make those really easy to add too, right?

ROZA. Yes, functions at the meta-level are parametric, so they correspond exactly to
single variable binding -- they cannot perform any computation, and thus we do not have to
worry about exotic terms. So this works fine for Church-style lambdas:

*)

lam : typ -> (term -> term) -> term.

(*

HAGOP. I see. And how about the typing judgement, $\Gamma \vdash e : \tau$ ?

ROZA. Let's add a predicate for that. Only, no $\Gamma$, there is an implicit context
of assumptions that will serve the same purpose.

*)

typeof : term -> typ -> prop.

(*

HAGOP. Let me see if I can get the typing rule for application. I know that in Prolog we
write the conclusion of a rule first, and the premises follow the `:-` sign. Does
something like this work?

*)

typeof (app E1 E2) T' :-
  typeof E1 (arrow T T'), typeof E2 T.

(*

ROZA. Yes! That's exactly right. Makam uses capital letters for unification variables.

HAGOP. I will need help with the lambda typing rule though. What's the equivalent of
extending the context as in $\Gamma, x : \tau$ ?

ROZA. Simple, we introduce a fresh constructor for terms, and a new typing rule for it:

*)

typeof (lam T1 E) (arrow T1 T2) :-
  (x:term -> typeof x T1 -> typeof (E x) T2).

(*

HAGOP. Hmm, so `x:term ->` introduces the fresh constructor standing for the new
variable, and `typeof x T1 ->` introduces the new assumption? Oh, and we need to get to
the body of the lambda function in order to type-check it, that's why you do `E x`.

ROZA. Yes. Note that the introductions are locally scoped, so they are only into effect
for the recursive call to `typeof`.

HAGOP. Makes sense. So do we have a type checker already? Can we run queries?

ROZA. We do! Observe:

*)

typeof (lam _ (fun x => x)) T ?
(* >> Yes: *)
(* >> T := arrow T1 T1 *)

(*

HAGOP. Cool! So underscores for unification variables we don't care about, and `?` for
queries. But wait, last time I implemented unification in my toy STLC implementation it
was easy to make it go into an infinite loop with $\lambda x. x x$. How does that work
here?

ROZA. Well you were missing the occurs-check. \lamprolog unification includes it:

*)

typeof (lam _ (fun x => app x x)) T' ?
(* >> Impossible. *)

(*

HAGOP. Right. So let's see, what else can we do? How about adding tuples to our language?
Can we use something like a polymorphic list?

ROZA. Sure, \lamprolog has polymorphic types and higher-order predicates:

```
list : type -> type.
nil : list A.
cons : A -> list A -> list A.

map : (A -> B -> prop) -> list A -> list B -> prop.
map P nil nil.
map P (cons X XS) (cons Y YS) :- P X Y, map P XS YS.
```

HAGOP. Nice! I guess that's why you wanted to go with \lamprolog for doing this instead of
LF, since you cannot use polymorphism there?

ROZA. Indeed. We will see, once we figure out what our language should be, one thing we
could do is transcribe our definitions to LF, and then we could even use Beluga
\citep{pientka2008programming} to do all our metatheoretic proofs.

HAGOP. Sounds good. So, for tuples, this should work:

*)

tuple : list term -> term.
product : list typ -> typ.
typeof (tuple ES) (product TS) :-
  map typeof ES TS.

(*

ROZA. Yes, and we can use syntactic sugar for `cons` and `nil` too:

*)

typeof (lam _ (fun x => lam _ (fun y => tuple [x, y]))) T ?
(* >> Yes: *)
(* >> T := arrow T1 (arrow T2 (product [T1, T2])) *)

(*

HAGOP. So how about evaluation? Can we write the big-step semantics too?

ROZA. Why not? Let's add a predicate and do the two easy rules:

*)

eval : term -> term -> prop.
eval (lam T F) (lam T F).
eval (tuple ES) (tuple VS) :- map eval ES VS.

(*

HAGOP. OK, let me try my hand at the beta-redex case. I'll just do call-by-value. And I
think in \lamprolog function application is exactly capture-avoiding substitution, so
this should be fine:

*)

eval (app E E') V'' :-
  eval E (lam _ F), eval E' V', eval (F V') V''.

(*

ROZA. Exactly! See, I told you this would be easy!
*)

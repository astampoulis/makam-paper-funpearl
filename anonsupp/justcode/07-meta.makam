%use "06-synonyms".

depindex, depclassifier, depvar : type.
depclassify : depindex -> depclassifier -> prop.
depclassify : depvar -> depclassifier -> prop.
depwf : depclassifier -> prop.
depsubst : [A] (depvar -> A) -> depindex -> A -> prop.

lamdep : depclassifier -> (depvar -> term) -> term.
appdep : term -> depindex -> term.
liftdep : depindex -> term. liftdep : depclassifier -> typ.
pidep : depclassifier -> (depvar -> typ) -> typ.
typeof (lamdep C EF) (pidep C TF) :-
  (v:depvar -> depclassify v C -> typeof (EF v) (TF v)), depwf C.
typeof (appdep E I) T' :- typeof E (pidep C TF), depclassify I C, depsubst TF I T'.
typeof (liftdep I) (liftdep C) :- depclassify I C.

%import "02-stlc" as object.
%extend object.
nat : typ. zero : term. succ : term -> term.
typeof zero nat.
typeof (succ N) nat :- typeof N nat.
eval zero zero.
eval (succ E) (succ V) :- eval E V.
%end.

%extend object.
wftyp : typ -> prop.
lam : typ -> (term -> term) -> term.
typeof (lam T E) (arrow T T') :-
  (x:term -> typeof x T -> typeof (E x) T'), wftyp T.
%end.

iterm : object.term -> depindex.     ityp : object.typ -> depindex.
ctyp : object.typ -> depclassifier.  cext : depclassifier.
depclassify (iterm E) (ctyp T) :- object.typeof E T.
depclassify (ityp T) cext :- object.wftyp T.
depwf (ctyp T) :- object.wftyp T.
depwf cext.

%extend object.
wftyp_aux : [A] A -> A -> prop.
wftyp_cases, wftyp_applies : [A] A -> prop.
wftyp T :- wftyp_aux T T.
wftyp_aux T T :- if (wftyp_applies T)
                 then (wftyp_cases T)
                 else (structural_recursion wftyp_aux T T).
%end.

depsubst_aux, depsubst_cases : [A] depvar -> depindex -> A -> A -> prop.
depsubst_applies : [A] depvar -> A -> prop.
depsubst F I Res :- (v:depvar -> depsubst_aux v I (F v) Res).
depsubst_aux Var Replace Where Res :-
  if (depsubst_applies Var Where)
  then (depsubst_cases Var Replace Where Res)
  else (structural_recursion (depsubst_aux Var Replace) Where Res).

%extend object.
varterm : depvar -> term.  vartyp : depvar -> typ.
typeof (varterm V) T :- depclassify V (ctyp T).
wftyp_applies (vartyp V). wftyp_cases (vartyp V) :- depclassify V cext.
%end.
depsubst_applies Var (object.varterm Var).
depsubst_cases Var (iterm Replace) (object.varterm Var) Replace.
depsubst_applies Var (object.vartyp Var).
depsubst_cases Var (ityp Replace)  (object.vartyp Var)  Replace.

typeof (lamdep cext (fun t =>
         (liftdep (iterm (object.lam (object.vartyp t) (fun x => x)))))) T ?
(* >> Yes!!!!! *)
(* >> T := pidep cext (fun t => *)
(* >>        liftdep (ctyp (object.arrow (object.vartyp t) (object.vartyp t)))) *)

iopen_term : bindmany object.term object.term -> depindex.
cctx_typ : list object.typ -> object.typ -> depclassifier.

foreach : [A] (A -> prop) -> list A -> prop.
foreach P [].
foreach P (HD :: TL) :- P HD, foreach P TL.

depclassify (iopen_term XS_E) (cctx_typ TS T) :-
  openmany XS_E (pfun xs e =>
    assumemany object.typeof xs TS (object.typeof e T),
    foreach object.wftyp TS).
depwf (cctx_typ TS T) :- foreach object.wftyp TS, object.wftyp T.

%extend object.
varmeta : depvar -> list term -> term.
typeof (varmeta V ES) T :- depclassify V (cctx_typ TS T), map object.typeof ES TS.
%end.
depsubst_applies Var (object.varmeta Var _).
depsubst_cases Var (iopen_term XS_E) (object.varmeta Var ES) Result :-
  applymany XS_E ES E', depsubst_aux Var (iopen_term XS_E) E' Result.

typeof (lamdep _ (fun t1 => (lamdep _ (fun t2 =>
       (lamdep (cctx_typ [object.vartyp t1] (object.vartyp t2)) (fun f =>
       (lamdep _ (fun a => (liftdep (iopen_term (bindbase (
         (object.varmeta f [object.varterm a]))))))))))))) T ?
(* >> Yes: *)
(* >> T := (pidep (cext (fun t1 => pidep (cext (fun t2 => *)
(* >>      (pidep (cctx_typ [object.vartyp t1] (object.vartyp t2)) (fun f => *)
(* >>      (pidep (ctyp (object.vartyp t1)) (fun a => *)
(* >>      (liftdep (cctx_typ [] (object.vartyp t2)))))))))))) *)

(eq _FUNCTION 
       (lamdep _ (fun t1 => (lamdep _ (fun t2 =>
       (lamdep (cctx_typ [object.vartyp t1] (object.vartyp t2)) (fun f =>
       (lamdep _ (fun a => (liftdep (iopen_term (bindbase (
         (object.varmeta f [object.varterm a]))))))))))))),
 typeof (appdep (appdep (appdep _FUNCTION (ityp object.nat)) (ityp object.nat))
           (iopen_term (bindnext (fun x => bindbase (object.succ x))))) T) ?
(* >> Yes: *)
(* >> T := pidep (ctyp object.nat) (fun a => liftdep (cctx_typ nil object.nat)) *)


%use "05-miniml".
tests: testsuite. %testsuite tests.

type_synonym : dbind typ T typ -> (typeconstructor T -> program) -> program.
type_synonym_info : typeconstructor T -> dbind typ T typ -> prop.
wfprogram (type_synonym Syn Program') :-
  (t:(typeconstructor T) -> type_synonym_info t Syn -> wfprogram (Program' t)).

teq : typ -> typ -> prop.

already_in : [A] A -> prop.
typeof E T :- not(refl.isunif T), not(already_in (typeof E)),
              (already_in (typeof E) -> typeof E T'), teq T T'.

typeof (P : patt A B) S' S T :-
  not(refl.isunif T),
  not(already_in (typeof P)),
  (already_in (typeof P) -> typeof P S' S T'),
  teq T T'.

structural_recursion : [A B] (A -> A -> prop) -> B -> B -> prop.

structural_recursion Rec X Y :-
  refl.headargs X Constructor Arguments,
  dyn.map Rec Arguments Arguments',
  refl.headargs Y Constructor Arguments'.

structural_recursion Rec (X : A -> B) (Y : A -> B) :-
  (x:A -> structural_recursion Rec x x -> structural_recursion Rec (X x) (Y x)).

teq' : [A] A -> A -> prop.
teq T T' :- teq' T T'.
teq' (tconstr TC Args) T' :-
  type_synonym_info TC Synonym, applymany Synonym Args T, teq' T T'.
teq' T' (tconstr TC Args) :-
  type_synonym_info TC Synonym, applymany Synonym Args T, teq' T' T.
teq' T T' :- structural_recursion teq' T T'.

wfprogram (
  (type_synonym (dbindnext (fun a => dbindbase (product [a, a])))
  (fun bintuple => 
  
  main (lam (tconstr bintuple [product [nat, nat]])
            (fun x => 
    case_or_else x
    (patt_tuple [patt_tuple [patt_wild, patt_wild], patt_tuple [patt_wild, patt_wild]])
    (dbindbase (tuple []))
    (tuple [])
  ))
))) ?
>> Yes.

wfprogram (
  (type_synonym (dbindnext (fun a => dbindbase (product [a, a])))
  (fun bintuple => 
  
  main (lam (tconstr bintuple [product [nat, nat]])
            (fun x => 
    case_or_else x
    (patt_tuple [patt_tuple [patt_wild], patt_tuple [patt_wild, patt_wild]])
    (dbindbase (tuple []))
    (tuple [])
  ))
))) ?
>> Impossible.


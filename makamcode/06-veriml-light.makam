(*
# Where our heroes tackle dependencies, contexts, and a new level of meta

*)

%use "05-type-synonyms".

(*

STUDENT. I'm fairly confident by now that Makam should be able to handle the research idea
we want to try out. Shall we get to it?

ADVISOR. Yes, it is time. So, what we are aiming to do, is add a facility for type-safe, heterogeneous meta-programming to our object language, similar to MetaHaskell \citep{mainland2012explicitly}. This way we can manipulate the terms of a separate object language in a type-safe manner.

STUDENT. Exactly. We'd like our object language to be a formal logic, so our language will
be similar to Beluga \citep{pientka2010beluga} or VeriML
\citep{stampoulis2013veriml}. We'll have to be able to pattern match over the terms of the
object language, too, so they are runtime entities too.... But we don't need to do all of
that, let's just do a basic version for now, and I can do the rest on my own.

ADVISOR. Sounds good. So, I think the fragment we should do is this: we will have
dependent functions over a distinguished language of *dependent indices*. We need the
dependency so that, for example, we can take an object-level type as an argument, and
return an object-level term that uses that type.

STUDENT. Exactly. Dependent products should be similar, but we can skip them for now, and just add a way to return an object-level term from the meta-level terms.

ADVISOR. Good idea. We are getting into many levels of meta -- there's the meta-language
we're using, Makam; there's the object language we are encoding, which is a meta-language
in itself, let's call that Heterogeneous Meta ML Light (HMML?); and there's the
"object-object" language that HMML is manipulating. And let's keep that last one simple: the simply typed lambda calculus (STLC).

STUDENT. Great. So, our dependent indices will be the types and terms of STLC -- actually, the open terms of STLC.

ADVISOR. It's a plan. So, let's get to it. Let's first add distinguished sorts for dependent indices, and dependent classifiers -- we'll use those to type-check the indices, using an appropriate predicate. Let's also have a distinguished type for *dependent variables*, that is, variables of dependent indices; and a way to substitute such a variable for an object.

*)

depindex, depclassifier, depvar : type.
depclassify : depindex -> depclassifier -> prop.
depclassify : depvar -> depclassifier -> prop.
depsubst : [A] (depvar -> A) -> depindex -> A -> prop.

(*

\newcommand\dep[1]{\ensuremath{#1_{\text{d}}}}
\newcommand\lift[1]{\ensuremath{\langle#1\rangle}}

STUDENT. Right, we might need to treat variables specially, so it's good that they're a different type. And let's assume that classifiers are well-formed by construction. 

ADVISOR. Now, we have a few typing rules to add. I'll use ``$\dep{\cdot}$'' to signify things that have to do with the dependent indices.

\vspace{-1em}
\begin{mathpar}
\small
\inferrule{\dep{\Psi} \dep{\vdash} \dep{c} : \dep{i}}
          {\Gamma; \dep{\Psi} \vdash \lift{\dep{c}} : \lift{\dep{i}}}

\inferrule{\Gamma; \dep{\Psi}, \; \dep{v} : \dep{c} \vdash e : \tau}
          {\Gamma; \dep{\Psi} \vdash \Lambda \dep{v} : \dep{c}.e : \Pi \dep{v} : \dep{c}.\tau}

\inferrule{\Gamma; \dep{\Psi} \vdash e : \Pi \dep{v} : \dep{c}.\tau \\ \dep{\Psi} \dep{\vdash} \dep{i} : \dep{c}}
          {\Gamma; \dep{\Psi} \vdash e @ \dep{c} : \dep{\text{subst}}(\tau, [\dep{i}/\dep[v]])}
\end{mathpar}

STUDENT. Those are very easy to transcribe to Makam.

*)

lamdep : depclassifier -> (depvar -> term) -> term.
appdep : term -> depindex -> term.
liftdep : depindex -> term. liftdep : depclassifier -> typ.
pidep : depclassifier -> (depvar -> typ) -> typ.

typeof (lamdep C EF) (pidep C TF) :-
  (v:depvar -> depclassify v C -> typeof (EF v) (TF v)).
typeof (appdep E I) T' :- typeof E (pidep C TF), depclassify I C, depsubst TF I T'.
typeof (liftdep I) (liftdep C) :- depclassify I C.

(*

ADVISOR. Great. Just wanted to say, this framework is quite general. We could instantiate dependent indices with a language of natural numbers, equality predicates, and equality proofs; this would be quite similar to the Dependent ML formulation of \citet{licata2005formulation}. But let's go back to what we're trying to do. I'll add the object language in a separate namespace prefix, and I'll just copy-paste our STLC code from earlier on.

```
%extend object.
term : type. typ : type. typeof : term -> typ -> prop.
%end.
```

We don't have to copy-paste the code, we can import the previous file into a separate namespace. But let's add natural numbers too.

*)

%import "01-base-language" as object.
%extend object.
nat : typ. zero : term. succ : term -> term.
typeof zero nat.
typeof (succ N) nat :- typeof N nat.
eval zero zero.
eval (succ E) (succ V) :- eval E V.
%end.

(*

*)

%extend object.
wftyp : typ -> prop. wftyp_cases, wftyp_aux : [A] A -> A -> prop.
%end.

(*

STUDENT. Great! I'll make these into dependent indices now, including both types and terms.

*)

iterm : object.term -> depindex.     ityp : object.typ -> depindex.
ctyp : object.typ -> depclassifier.  cext : depclassifier.

depclassify (iterm E) (ctyp T) :- object.typeof E T.
depclassify (ityp T) cext :- object.wftyp T.

(*

ADVISOR. Right, we'll need to check that types are well-formed, too. Right now, they are all well-formed by construction, but let's prepare for any additions, by setting up a structurally recursive predicate:

*)

%extend object.
wftyp : typ -> prop. wftyp_cases, wftyp_aux : [A] A -> A -> prop.
wftyp T :- wftyp_aux T T.
wftyp_aux T T :-
  if (wftyp_cases T T) then success else (structural_recursion wftyp_aux T T).
%end.

(*

STUDENT. I see -- your structural recursion just needs to do a visit, it does not need to produce an output; hence the repeat of the same `typ` argument. Let's prepare for substitutions too.

*)

depsubst_aux, depsubst_cases : [A] depvar -> depindex -> A -> A -> prop.
depsubst F I Res :- (v:depvar -> depsubst_aux v I (F v) Res).
depsubst_aux Var Replace Where Result :-
  if (depsubst_cases Var Replace Where Result)
  then (success)
  else (structural_recursion (depsubst_aux Var Replace) Where Result).

(*

ADVISOR. Great! We only have one thing missing: we need to close the loop, being able to refer to dependent variables from within object-level terms and types. By the way, we are very much following the construction in \citet{stampoulis2013veriml}.

STUDENT. I got this.

*)

%extend object.
varterm : depvar -> term.  vartyp : depvar -> typ.

typeof (varterm V) T :- depclassify V (ctyp T).
wftyp_cases (vartyp V) (vartyp V) :- depclassify T cext.
%end.

depsubst_cases Var (iterm Replace) (object.varterm Var) Replace.
depsubst_cases Var (ityp Replace)  (object.vartyp Var)  Replace.

(*

ADVISOR. This is exciting, let me try this out! I'll do a function that takes an
object-level type and returns the object-level identity function for it.

*)

typeof (lamdep cext (fun t =>
         (liftdep (iterm (object.lam (object.vartyp t) (fun x => x)))))) T ?
(* >> Yes!!!!! *)
(* >> T := pidep cext (fun t => *)
(* >>        liftdep (ctyp (object.arrow (object.vartyp t) (object.vartyp t)))) *)

(*

STUDENT. Wow, even the Makam REPL is excited!

ADVISOR. Wait until it sees what we have in store for it next: open STLC terms in our
indices!

STUDENT. Good thing I've printed out the contextual types paper by
\citet{nanevski2008contextual}. (...) OK, so it says here that we can use contextual types
to record at the type level, the context that open terms depend on. So let's say, an open
`object.term` of type $\tau$ that mentions variables of a $\Phi$ context would have a
contextual type of the form $[\Phi] \tau$. This is some sort of modal typing, with a precise context.

ADVISOR. 

We can also handle the case of non-closed terms, using contextual types:
*)

%extend object.
subst : type -> type.
subst : list A -> subst A.

ctx : type -> type.
ctx : subst typ -> bindmany term A -> ctx A.

openctx : ctx A -> (subst term -> subst typ -> A -> prop) -> prop.
applyctx : ctx A -> subst term -> A -> prop.

openctx (ctx Types Binds) P :-
  openmany Binds (pfun vars body =>
    P (subst vars) Types body
  ).

applyctx (ctx _ Binds) (subst Args) Result :-
  applymany Binds Args Result.

map : (A -> B -> prop) -> subst A -> subst B -> prop.
map P (subst L) (subst L') :- map P L L'.
%end.

openterm : object.ctx object.term -> depindex.
ctxtyp : object.subst object.typ -> object.typ -> depclassifier.

depclassify (openterm CtxE) (ctxtyp Typs T) :-
  object.openctx CtxE (pfun vars typs e => [Units]
    object.map (pfun t u => object.wftyp t) typs (Units : object.subst unit),
    object.map eq typs Typs,
    object.typeof e T).

(*

And one last step: reify open terms back into the language:

*)

%extend object.
metaterm : depindex -> subst term -> term.

typeof (metaterm E ES) T :-
  refl.isnvar E,
  depclassify E (ctxtyp Typs T),
  object.map object.typeof ES Typs.
%end.

depsubst_cases Var (openterm CtxE) (object.metaterm Var Subst) Result :-
  object.applyctx CtxE Subst E,
  depsubst_aux Var (openterm CtxE) E Result.

(*


Here is the final example program.

*)

(eq _FUNCTION
  (lamdep ext (fun t1 =>
    (lamdep ext (fun t2 =>
    (lamdep (ctxtyp (object.subst [object.metatyp t1]) (object.metatyp t2)) (fun x_e =>
    (packdep (openterm (object.ctx (object.subst []) (bindbase (object.lam _ (fun x =>
      object.tuple [object.metaterm x_e #SUBST, object.intconst 5]
    ))))) (tuple []) (fun _ => product [])))))))),
 typeof _FUNCTION FUNCTION_TYPE,

 typeof 
  (appdep (appdep 
    _FUNCTION 
    (typ object.tint)) 
    (typ (object.product [object.tint])))
 APPLIED_TYPE) ?
(* >> Yes: *)
(* >> SUBST := fun t1 t2 x_e x => subst (cons x nil), *)
(* >> FUNCTION_TYPE := *)
(* >>  pidep ext (fun t1 => *)
(* >>  pidep ext (fun t2 => *)
(* >>  pidep (ctxtyp (object.subst (cons (object.metatyp t1) nil)) (object.metatyp t2)) *)
(* >>  (fun x_e => *)
(* >>    sigdep  *)
(* >>      (ctxtyp (subst nil)  *)
(* >>       (arrow *)
(* >>         (object.metatyp t1) *)
(* >>         (product (cons (object.metatyp t2) (cons tint nil))))) *)
(* >>     (fun _ => product nil)))), *)
(* >> APPLIED_TYPE := *)
(* >>  pidep (ctxtyp *)
(* >>    (object.subst (cons object.tint nil)) *)
(* >>    (object.product (cons object.tint nil))) *)
(* >>  (fun x_e => *)
(* >>    sigdep (ctxtyp *)
(* >>      (subst nil) *)
(* >>      (arrow *)
(* >>        object.tint *)
(* >>        (product (cons (object.product (cons object.tint nil)) (cons tint nil))))) *)
(* >>    (fun _ => product nil)) *)

(*

Note that we can infer both the type of the lambda abstraction and the substitution
itself. Getting to that point in the VeriML implementation took months!

Mention that adding polymorphic contexts and dependent pattern matching as in VeriML is
also possible, but we won't show it here.
*)

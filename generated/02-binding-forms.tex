\section{Where our heroes add parentheses and discover how to do
multiple
binding}\label{where-our-heroes-add-parentheses-and-discover-how-to-do-multiple-binding}

\heroSTUDENT{} Still, I feel like we've been playing to the strengths of
\foreignlanguage{greek}{λ}Prolog\ldots{}. Yes, single-variable binding, substitutions, and so on
work nicely, but how about any other form of binding? Say, binding
multiple variables at the same time? We are definitely going to need
that for the language we have in mind. I was under the impression that
HOAS encodings do not work for such forms of binding -- for example, I
was reading \citet{keuchel2016needle} recently and I remember reading
something like that.

\heroADVISOR{} That's not really true; having first-class support for
single-variable binders should be enough, and I think this is
well-understood. But let's try it out, maybe adding multiple-argument
functions for example -- I mean uncurried ones. Want to give it at try?

\heroSTUDENT{} Let me see. Well, I want to write something like this, but I
know this is wrong.

\begin{verbatim}
lammany : (list term \ensuremath{\to} term) \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} Yes, that doesn't quite work. It would introduce a fresh
variable for \texttt{list}s, not a number of fresh variables for
\texttt{term}s. HOAS functions are parametric, too, which means we
cannot even get to the potential elements of the fresh \texttt{list}
inside the \texttt{term}.

\heroSTUDENT{} Right. So I don't know, instead we want to use a type that
stands for \texttt{term\ \ensuremath{\to}\ term},
\texttt{term\ \ensuremath{\to}\ term\ \ensuremath{\to}\ term}, and so on.
Can we write \texttt{term\ \ensuremath{\to}\ ...\ \ensuremath{\to}\ term}?

\heroADVISOR{} Well, not quite, but we have already defined something similar,
a type that roughly stands for \texttt{term\ *\ ...\ *\ term}, and we
did not need anything special for that\ldots{}

\heroSTUDENT{} You mean the \texttt{list} type?

\heroADVISOR{} Exactly. What do you think about this definition?

\begin{verbatim}
bindmanyterms : type.
bindnil : term \ensuremath{\to} bindmanyterms.
bindcons : (term \ensuremath{\to} bindmanyterms) \ensuremath{\to} bindmanyterms.
\end{verbatim}

\heroSTUDENT{} Hmm. That looks quite similar to lists; the parentheses in
\texttt{cons} are different. \texttt{nil} gets an extra \texttt{term}
argument, too\ldots{}

\heroADVISOR{} Yes\ldots{} So what is happening here is that \texttt{bindcons}
takes a single argument, introducing a binder; and \texttt{bindnil} is
when we get to the body and don't need any more binders. Maybe we should
name them accordingly.

\heroSTUDENT{} Right, and could we generalize their types? Maybe that will
help me get a better grasp of it. How is this?

\begin{verbatim}
bindmany : type \ensuremath{\to} type \ensuremath{\to} type.
body : Body \ensuremath{\to} bindmany Variable Body.
bind : (Variable \ensuremath{\to} bindmany Variable Body) \ensuremath{\to} bindmany Variable Body.
\end{verbatim}

\heroADVISOR{} This looks great! We have allowed binding zero variables, but
that makes the constructors nicer and will simplify our predicates too.

\heroSTUDENT{} I see. That is an interesting datatype. Is there some reference
about it?

\heroADVISOR{} Not that I know of, at least where it is called out as a
reusable datatype -- though the construction is definitely part of PL
folklore. After I started using this in Makam, I noticed similar
constructions in the wild, for example in MTac \citep{ziliani2013mtac},
for parametric HOAS implementation of telescopes in Coq.

\heroSTUDENT{} Interesting. So how do we work with \texttt{bindmany}? I know
we can now define \texttt{lammany} now, but how about the typing rule?

\begin{verbatim}
lammany : bindmany term term \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} The rule will be like this, but I'll explain what goes into it:

\begin{verbatim}
arrowmany : list typ \ensuremath{\to} typ \ensuremath{\to} typ.
typeof (lammany F) (arrowmany TS T) :-
  openmany F (fun xs body \ensuremath{\Rightarrow}
    assumemany typeof xs TS (typeof body T)).
\end{verbatim}

\heroSTUDENT{} Let me see if I can read this\ldots{} \texttt{openmany} somehow
gives you fresh variables \texttt{xs} for the binders, and the
\texttt{body} of the \texttt{lammany}; and then the
\texttt{assumemany\ typeof} part is what corresponds to extending the
\(\Gamma\) context with multiple typing assumptions?

\heroADVISOR{} Yes, and then we typecheck the \texttt{body} in that local
context. But let's do one step at a time. \texttt{openmany} is simple;
we iterate through the nested binders, introducing one fresh variable at
a time, and substituting each bound variable for the fresh variable.

\begin{verbatim}
openmany : bindmany A B \ensuremath{\to} (list A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
openmany (body Body) P :- P [] Body.
openmany (bind F) P :-
  (x:A \ensuremath{\to} openmany (F x) (fun xs \ensuremath{\Rightarrow} P (x :: xs))).
\end{verbatim}

\heroSTUDENT{} I guess \texttt{assumemany} is similar, introducing one
assumption at a time?

\begin{verbatim}
assumemany : (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} list A \ensuremath{\to} list B \ensuremath{\to} prop \ensuremath{\to} prop.
assumemany P [] [] Q :- Q.
assumemany P (X :: XS) (Y :: YS) Q :- (P X Y \ensuremath{\to} assumemany P XS YS Q).
\end{verbatim}

\heroTODO{} Use a reference below and refine wording.

\heroADVISOR{} Yes, exactly! Just a note though -- \lamprolog typically does
not allow the definition of \texttt{assumemany}, where a non-concrete
predicate like \texttt{P\ X\ Y} is used as an assumption, because of
logical reasons. Makam is more lax, and so is ELPI, another recent
\lamprolog implementation, and allows this form statically, though there
are instantiations of \texttt{P} that will fail at run-time.

\heroSTUDENT{} Can I try this out?

\begin{verbatim}
typeof (lammany (bind (fun x \ensuremath{\Rightarrow} bind (fun y \ensuremath{\Rightarrow} body (tuple [y, x]))))) T ?
>> Yes:
>> T := arrowmany [T1, T2] (product [T2, T1]).
\end{verbatim}

\heroTODO{} (Still WIP below!!)

\heroSTUDENT{} Great, I think I got the hang of this. We could definitely add
a multiple-argument application construct \texttt{appmany} or define the
rules for \texttt{eval} for these. But that would be easy; we can do it
later. Something that worries me, though -- all these fancy higher-order
abstract binders, how do we \ldots{} make them concrete? Say, how do we
print them?

\heroADVISOR{} That's actually quite easy. We just add a concrete name to
them. A plain old \texttt{string}. Our typing rules etc. do not care
about it, but we could use it for parsing concrete syntax into our
abstract binding syntax, or for pretty-printing\ldots{}. Let's not get
into that for the time being, but let's just say that we could have
defined \texttt{bind} with an extra \texttt{string} argument; and then
\texttt{openmany} could just ignore it.

\begin{verbatim}
bind : string \ensuremath{\to} (Var \ensuremath{\to} bindmany Var Body) \ensuremath{\to} bindmany Var Body.
\end{verbatim}

\heroSTUDENT{} Interesting. I would like to see more about this, but maybe
some other time. I thought of another thing that could be challenging:
mutually recursive \texttt{let\ rec}s?

\heroADVISOR{} Sure -- how about this?

\begin{verbatim}
letrec : bindmany term (list term * term) \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Bind many terms into a list of terms and a term. I guess
\texttt{*} is for tuples\ldots{} Is the first element the definitions
and the second element the body?

\heroADVISOR{} Yes -- so, for this expression \ldots{}

\begin{verbatim}
let rec f = f_def and g = g_def in body
\end{verbatim}

\heroSTUDENT{} \ldots{} we would write something like this:

\begin{verbatim}
letrec (bind f g \ensuremath{\Rightarrow} body ([f_def, g_def], body))
\end{verbatim}

\heroADVISOR{} Yes, and we need to be careful so that the number of binders
matches the number of definitions in the list. We can go ahead and
encode that in our typing rules\ldots{}.

\heroSTUDENT{} Wait. I let you get away before with the zero binders in
\texttt{bindmany}, but this is pushing it a little bit. It doesn't sound
like an accurate encoding.

\heroADVISOR{} You're right, but we would need some sort of dependency to
enforce those kinds of limitations\ldots{} and \foreignlanguage{greek}{λ}Prolog does not have
dependent types.

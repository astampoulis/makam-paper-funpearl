\section{Where our heroes get out of the bind using ad-hoc
polymorphism}\label{where-our-heroes-get-out-of-the-bind-using-ad-hoc-polymorphism}

\heroSTUDENT{} No dependent types\ldots{} so what is the \foreignlanguage{greek}{λ}Prolog type system?
Is it some version of System F?

\heroADVISOR{} It is a subset of System F\(_\omega\) actually -- so, the
simply typed lambda calculus, plus prenex polymorphism, plus simple type
constructors of the form
\texttt{type\ \ensuremath{\to}\ type\ \ensuremath{\to}\ ...\ \ensuremath{\to}\ type}.
The \texttt{prop} sort of propositions is a bit special, since we can
only add rules to its inhabitants, but otherwise it is just a normal
type.

\heroSTUDENT{} I see. So, that is quite similar to base Haskell -- without the
recent extensions with kind definitions \citep{yorgey2012giving} or
Type-in-Type \citep{weirich2013system} -- and it is still possible to
have dependently typed datatypes there through GADTs.

\heroADVISOR{} How so?

\heroSTUDENT{} Well, you can use empty datatypes to encode type-level data, by
exploiting the type parameters\ldots{} For example, you could do
type-level natural numbers with \texttt{NatZ\ ::\ *} and
\texttt{NatS\ ::\ *\ \ensuremath{\to}\ *} and then use them as a
``dependent'' index for vectors.

\heroADVISOR{} Oh, right, I forgot about that. Well, we could do the same
thing in Makam then:

\begin{verbatim}
natZ : type.
natS : type \ensuremath{\to} type.

vector : type \ensuremath{\to} type \ensuremath{\to} type.
vnil : vector natZ A.
vcons : A \ensuremath{\to} vector N A \ensuremath{\to} vector (natS N) A.
\end{verbatim}

\heroSTUDENT{} Oh, so \foreignlanguage{greek}{λ}Prolog supports GADTs? Pattern matching propagates type
information and everything?

\heroADVISOR{} Well, it does not work quite the same way, but yes. The way it
works in \foreignlanguage{greek}{λ}Prolog is through \emph{ad-hoc polymorphism}: polymorphic type
variables can be unified at \emph{runtime} rather than at type-checking
time. So before performing term-level unification, type-level
unification is done, so uninstantiated type variables can be further
determined; we can thus ``learn'' and propagete extra type information
at runtime. So we could do \texttt{map} for vectors as follows:

\begin{verbatim}
vmap : [N] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} vector N A \ensuremath{\to} vector N B \ensuremath{\to} prop.
vmap P vnil vnil.
vmap P (vcons X XS) (vcons Y YS) :- P X Y, vmap P XS YS.
\end{verbatim}

\heroSTUDENT{} Interesting. The \texttt{{[}N{]}} notation in the type of
\texttt{vmap}, what is that?

\heroADVISOR{} Well, type arguments for propositions are parametric by
default, so that says that \texttt{N} is ad-hoc polymorphic -- rules can
specialize it further. And the reason for that is that we are used to
type arguments being parametric, and we can catch some errors that way
-- for example this erroneous \texttt{fold} is still well-typed if the
type arguments are ad-hoc:

\begin{verbatim}
foldl : (B \ensuremath{\to} A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} B \ensuremath{\to} list A \ensuremath{\to} B \ensuremath{\to} prop.
foldl P S nil S.
foldl P S (cons HD TL) S'' <- P HD S S', foldl P S' TL S''.
\end{verbatim}

\heroSTUDENT{} Oh, the \texttt{HD} argument in the call to \texttt{P} should
be second instead of first -- and this definition would only work when
\texttt{A} and \texttt{B} are the same?

\heroADVISOR{} Precisely, but we would only find out at runtime, if it was
called with \texttt{A} and \texttt{B} being different.

\heroSTUDENT{} I see. So type-level unification, is that a standard \foreignlanguage{greek}{λ}Prolog
feature, or just Makam?

\heroADVISOR{} It's hard to say. I think this was part of the original design
by \citet{miller1988overview}, but I have not come upon any examples
that actively use it so far -- for example, the book by
\citet{miller2012programming} hardly mentions the feature, and the
standard \foreignlanguage{greek}{λ}Prolog implementation, Teyjus \citet{nadathur1999system}, has
a few issues related to polymorphic types that have not allowed me to
test this there.

\heroSTUDENT{} Well let's see if it is actually useful for what we were trying
to do. Maybe we can use this feature for a better encoding of
\texttt{letrec}? We could do the \texttt{vector} equivalent of
\texttt{bindmany}, carrying a type argument for the number of binders,
so that we can reuse that for a \texttt{vector} of definitions:

\begin{verbatim}
dbind : type \ensuremath{\to} type \ensuremath{\to} type \ensuremath{\to} type. 
dbindbase : B \ensuremath{\to} dbind A natZ B.
dbindnext : (A \ensuremath{\to} dbind A N B) \ensuremath{\to} dbind A (natS N) B.
letrec : dbind term N (vector N term * term) \ensuremath{\to} term.
\end{verbatim}

\heroADVISOR{} That looks good, but I do not like this natural number trick --
if we could define a new \texttt{nat} kind and specify that in the type
of \texttt{dbind}, it would be fine, but as it stands\ldots{} Well,
here's an idea. The ``dependent'' index could be the type of
\texttt{n}-tuples of variables, rather than \texttt{n} itself:

\begin{verbatim}
dbind : type \ensuremath{\to} type \ensuremath{\to} type \ensuremath{\to} type.
dbindbase : B \ensuremath{\to} dbind A unit B.
dbindnext : (A \ensuremath{\to} dbind A T B) \ensuremath{\to} dbind A (A * T) B.
\end{verbatim}

\heroSTUDENT{} That should work. Should we also define the equivalent of
\texttt{vector} with the same type of index?

\heroADVISOR{} Sure. We could just use the tuple type \texttt{T} and do
pattern-matching on whether it's equal to \texttt{A\ *\ B} or
\texttt{unit}, but constructor-based pattern matching reads much better.
Let's call it \texttt{subst} for substitutions:

\begin{verbatim}
subst : type \ensuremath{\to} type \ensuremath{\to} type.
nil : subst A unit.
cons : A \ensuremath{\to} subst A T \ensuremath{\to} subst A (A * T).
\end{verbatim}

\heroSTUDENT{} We are already using \texttt{nil} and \texttt{cons} for lists,
should we call the constructors something else?

\heroADVISOR{} No, this works fine, and we can reuse the syntactic sugar for
them. Makam allows overloading for all constants, it takes
statically-known type information into account for resolving variables
and disambiguating between them. Sometimes you have to do a type
ascription, but I find it works nicely in most cases.

\heroSTUDENT{} I see. So let me try my hand at writing the helper predicates
that we'll need for \texttt{dbind} and \texttt{subst}. How do these
look?

\begin{verbatim}
intromany : [T] dbind A T B \ensuremath{\to} (subst A T \ensuremath{\to} prop) \ensuremath{\to} prop.
applymany : [T] dbind A T B \ensuremath{\to} subst A T \ensuremath{\to} B \ensuremath{\to} prop.
openmany : [T] dbind A T B \ensuremath{\to} (subst A T \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} prop.
assumemany : [T T'] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} subst A T \ensuremath{\to} subst B T' \ensuremath{\to} prop \ensuremath{\to} prop.
map : [T T'] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} subst A T \ensuremath{\to} subst B T' \ensuremath{\to} prop.
\end{verbatim}

\heroADVISOR{} These look fine -- they're quite similar to the ones for
\texttt{bindmany}. \texttt{assumemany} and \texttt{map} do not really
capture the relationship between \texttt{T} and
\texttt{T\textquotesingle{}}, which are the same tuples save for
\texttt{A}s being replaced by \texttt{B}s\ldots{} but we don't have to
complicate this further, I am sure we could capture that if needed with
another dependent construction.

\heroSTUDENT{} That's what I was thinking too. Let me see, I think most of
these are almost identical to what we had before.

\begin{verbatim}
intromany (dbindbase F) P :- P [].
intromany (dbindnext F) P :- (x:A \ensuremath{\to} intromany (F x) (pfun t \ensuremath{\Rightarrow} P (x :: t))).
...
\end{verbatim}

\begin{scenecomment}
(Our heroes copy paste the code from before for the rest of the predicates,
changing `bindbase` to `dbindbase` and `bindnext` to `dbindnext`.)
\end{scenecomment}

\heroADVISOR{} Alright, I think we should be able to do \texttt{letrec} now!

\begin{verbatim}
letrec : dbind term T (subst term T * term) \ensuremath{\to} term.
typeof (letrec XS_DefsBody) T' :-
  openmany XS_DefsBody (pfun xs defsbody \ensuremath{\Rightarrow} [Defs Body]
    eq defsbody (Defs, Body),
    assumemany typeof xs TS (map typeof Defs TS),
    assumemany typeof xs TS (typeof Body T')
  ).
\end{verbatim}

\heroSTUDENT{} What is \texttt{eq}?

\heroADVISOR{} Oh, that's just to force unification with
\texttt{(Defs,\ Body)} and get the elements of the tuple -- there's no
destructuring \texttt{pfun}. \texttt{eq} is just defined as:

\begin{verbatim}
eq : A \ensuremath{\to} A \ensuremath{\to} prop.
eq X X.
\end{verbatim}

\heroSTUDENT{} I see. Say, can we use the same trick to do patterns?

\heroADVISOR{} We should be able to\ldots{} the linearity is going to be a bit
tricky, but I am fairly confident that having explicit support in our
metalanguage just for single-variable binding is enough to model most
complicated forms of binding, when we also make use of polymorphism and
GADTs.

\heroSTUDENT{} Makes sense. Well, I think I have an idea for patterns: we can
have a type argument to keep track of what variables they introduce.
Since within a pattern we can only refer to a variable once\ldots{} no
actual binding needs to take place. But we can use the type argument to
bind the right number of pattern variables into the body of a branch.

\heroADVISOR{} That is true\ldots{} One way I think about binding is that it
is just a way to introduce a notion of sharing into abstract syntax
trees, so that we can refer to the same thing a number of times. And
you're right that for patterns, the sharing happens from the side of the
pattern into the branch body, not within the pattern itself.

\heroSTUDENT{} Though there is some of that in dependent pattern matching,
where you can reuse a pattern variable and an exact matching takes place
rather than unification\ldots{}

\heroADVISOR{} \ldots{}Right. But let's not worry about that right now, let's
just do simple patterns. So at the top-level, a pattern will just have a
single ``tuple type'' argument with the variables it used. I am thinking
that for sub-patterns, we will need two arguments. One for all the
variables that \emph{can} be used, initially matching the type argument
of the top-level pattern; another argument, for the variables that
\emph{remain} to be used after this sub-pattern is traversed.

\heroSTUDENT{} I don't get that yet. Wait, let me first add natural numbers as
a base type so that we have a simple example.

\begin{verbatim}
nat : typ. zero : term. succ : term \ensuremath{\to} term.
typeof zero nat.
typeof (succ N) nat :- typeof N nat.
eval zero zero.
eval (succ E) (succ V) :- eval E V.
\end{verbatim}

\heroADVISOR{} Good idea. OK, so here's what I meant:

\begin{verbatim}
patt : type \ensuremath{\to} type \ensuremath{\to} type.
patt_var : patt (term * T) T.
patt_zero : patt T T.
patt_succ : patt T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroSTUDENT{} Hmm. So, you said the first argument is what variables are
``available'' when we go into the sub-pattern, second is what we're
``left with''\ldots{} so the variable case, we ``use up'' one variable,
in the zero case, we don't use any. And for successors, we just
propagate the variables.

\heroADVISOR{} Exactly. Could you do tuples?

\heroSTUDENT{} Let me see, I think I'll need a helper type for multiple
patterns\ldots{}

\begin{verbatim}
pattlist : type \ensuremath{\to} type \ensuremath{\to} type.
nil : pattlist T T.
cons : patt T1 T2 \ensuremath{\to} pattlist T2 T3 \ensuremath{\to} pattlist T1 T3.
patt_tuple : pattlist T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroADVISOR{} Exactly! And here's an interesting one: wildcards.

\begin{verbatim}
patt_wild : patt T T.
\end{verbatim}

\heroSTUDENT{} Oh, because that does not really introduce any pattern
variables that we can use. So if I understand this correctly, top-level
patterns should always use up all their variables -- they should end
with the second argument being \texttt{unit}, right?

\heroADVISOR{} Exactly, so this should be fine for a single-branch pattern
match construct:

\begin{verbatim}
case_or_else : term \ensuremath{\to} patt T unit \ensuremath{\to} dbind term T term \ensuremath{\to} term \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Let me parse that\ldots{} the first argument is the scrutinee,
the second is the pattern\ldots{} the third is the branch body, with the
pattern variables introduced. Oh, and the last argument is the
\texttt{else} case.

\heroADVISOR{} Right. And I think something like this should work for the
typing judgment. Let me write a few cases.

\begin{verbatim}
typeof : [T T' Ttyp T'typ] patt T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} typ \ensuremath{\to} prop.
typeof patt_var S' (cons T S') T.
typeof patt_wild S S T.
typeof patt_zero S S nat.
typeof (patt_succ P) S' S nat :- typeof P S' S nat.
\end{verbatim}

\heroSTUDENT{} I see, so given a pattern and the types of the variables
following the sub-pattern, we produce the types of all the variables,
and the type of the pattern itself. Makes sense. I'll do tuples:

\begin{verbatim}
typeof : [T T' Ttyp T'typ]
  pattlist T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} list typ \ensuremath{\to} prop.
typeof (patt_tuple PS) S' S (product TS) :- typeof PS S' S TS.
typeof [] S S [].
typeof (P :: PS) S3 S1 (T :: TS) :- typeof PS S3 S2 TS, typeof P S2 S1 T.
\end{verbatim}

\heroADVISOR{} Looks good. Can you do the typing rule for the case statement?

\heroSTUDENT{} How does this look?

\begin{verbatim}
typeof (case_or_else Scrutinee Pattern Body Else) T' :-
  typeof Scrutinee T,
  typeof Pattern nil TS T,
  openmany Body (pfun xs body \ensuremath{\Rightarrow} assumemany typeof xs TS (typeof body T')),
  typeof Else T'.
\end{verbatim}

\heroADVISOR{} That's great! This was a little tricky, but still, not too bad.
Actually I know of one thing that is surprisingly simple to do: the
evaluation rule. We just have to convert a pattern into a term, where we
replace the pattern variables with \emph{meta-level} unification
variables -- then we can just reuse meta-level unification to do the
actual pattern match!

\heroSTUDENT{} Oh, that would be nice. So not only do we get variable
substitutions for free, we also get unification for free in some cases!

\heroADVISOR{} Exactly. So something like this should work:

\begin{verbatim}
patt_to_term : [T T'] patt T T' \ensuremath{\to} term \ensuremath{\to} subst term T' \ensuremath{\to} subst term T \ensuremath{\to} prop.
patt_to_term patt_var X Subst (X :: Subst).
patt_to_term patt_wild _ Subst Subst.
patt_to_term patt_zero zero Subst Subst.
patt_to_term (patt_succ PN) (succ EN) Subst' Subst :- patt_to_term PN EN Subst' Subst.
\end{verbatim}

\heroSTUDENT{} I see, interesting! So in each rule we introduce the
unification variables that we need, like \texttt{X} for the variable
case, and store them in the substitution that we will use with the
pattern body.

\begin{scenecomment}
(Our heroes also write down the rules for multiple patterns and tuples, which are
available in the unabridged version of this story.)
\end{scenecomment}

\heroADVISOR{} We should be good to write the evaluation rule now.

\begin{verbatim}
eval (case_or_else Scrutinee Pattern Body Else) V :-
  patt_to_term Pattern TermWithUnifvars [] Unifvars,
  if (eq Scrutinee TermWithUnifvars)  (* reuse unification from the meta-language *)
  then (applymany Body Unifvars Body', eval Body' V)
  else (eval Else V).
\end{verbatim}

\heroSTUDENT{} I see! So, if meta-level unification is successful, we have a
match, and we substitute the instantiations we found for the pattern
variables into the body. But you are using if-then-else? We haven't used
that so far.

\heroADVISOR{} Oh yes, I forgot to mention that. It behaves as follows: when
there is at least one way to prove the condition, it proceeds to the
\texttt{then} branch, otherwise it goes to the \texttt{else} branch.
Pretty standard really. It is one thing that the Prolog cut statement,
\texttt{!}, is useful for, but cut introduces all sorts of trouble.
\citet{kiselyov05backtracking} is worth reading for alternatives to the
cut statement and the semantics of
\texttt{if}-\texttt{then}-\texttt{else} and \texttt{not} in logic
programming, and Makam follows that closely.

\heroSTUDENT{} Noted in my to-read list. But let us try pattern matching out!
How about predecessors for natural numbers? I'll write a query that
type-checks and evaluates a couple of cases.

\begin{verbatim}
(eq _PRED (lam _ (fun n \ensuremath{\Rightarrow} case_or_else n
  (patt_succ patt_var) (dbindnext (fun pred \ensuremath{\Rightarrow} dbindbase pred))
  zero)),
 typeof _PRED T,
 eval (app _PRED zero) PRED0, eval (app _PRED (succ (succ zero))) PRED2) ?
>> Yes:
>> T := arrow nat nat, PRED0 := zero, PRED2 := succ zero
\end{verbatim}

\heroADVISOR{} Seems to be working fine!

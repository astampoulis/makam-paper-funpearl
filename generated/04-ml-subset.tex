\section{Where our heroes add more ML features and reflect on structural
recursion}\label{where-our-heroes-add-more-ml-features-and-reflect-on-structural-recursion}

\begin{scenecomment}
(Our heroes need a small break, so they work on a couple of features improvising on the Rast makam\footnote{Makam is the system of melodic modes used in traditional Arabic and Turkish music and in the Greek rembetiko, comprised of a set of scales, patterns of melodic development, and rules for improvisation.}. Roza is singing, and Hagop is playing the oud.)
\end{scenecomment}

\begin{verse}
``Explicit System F polymorphism is easy, at some point we'll do Hindley-Milner too. \\
Types are well-formed by construction, an extra `$\vdash \tau \; \text{wf}$' judgement we won't do.
\end{verse}

\begin{verbatim}
forall : (typ \ensuremath{\to} typ) \ensuremath{\to} typ.
lamt : (typ \ensuremath{\to} term) \ensuremath{\to} term.
appt : term \ensuremath{\to} typ \ensuremath{\to} term.
typeof (lamt E) (forall T) :- (a:typ \ensuremath{\to} typeof (E a) (T a)).
typeof (appt E T) (TF T) :- typeof E (forall TF).
\end{verbatim}

\begin{verse}
``We are now adding top-level programs, to get into datatype declarations. \\
We would rather do modules, but those would need quite a bit of deliberation. \\
And we still got contextual types to do, those will require our full attention.''
\end{verse}

\begin{verbatim}
program : type.
wfprogram : program \ensuremath{\to} prop.

let : term \ensuremath{\to} (term \ensuremath{\to} program) \ensuremath{\to} program.
wfprogram (let E P) :- typeof E T, (x:term \ensuremath{\to} typeof x T \ensuremath{\to} wfprogram (P x)).

main : term \ensuremath{\to} program.
wfprogram (main E) :- typeof E _.
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\heroADVISOR{} I think we are ready to do polymorphic algebraic datatypes now.
We'll add a type for type constructors, like \texttt{list}, dependent on
their arity; and a type for the constructors of a datatype. Also a type
for constructor declarations, dependent on the number of constructors
they introduce:

\begin{verbatim}
typeconstructor : type \ensuremath{\to} type.
constructor : type.

ctor_declaration : type \ensuremath{\to} type.
nil : ctor_declaration unit.
cons : list typ \ensuremath{\to} ctor_declaration T \ensuremath{\to} ctor_declaration (constructor * T).
\end{verbatim}

\heroSTUDENT{} Oh, so each constructor takes multiple arguments. Great. So
datatype declarations would be something like this:

\begin{verbatim}
datatype_declaration : type \ensuremath{\to} type \ensuremath{\to} type.
datatype_declaration : 
  (typeconstructor Arity \ensuremath{\to} dbind typ Arity (ctor_declaration Ctors)) \ensuremath{\to}
  datatype_declaration Arity Ctors.

datatype :
  datatype_declaration Arity Ctors \ensuremath{\to}
  (typeconstructor Arity \ensuremath{\to} dbind constructor Ctors program) \ensuremath{\to}
  program.
\end{verbatim}

\heroADVISOR{} Right, so when declaring a datatype, we introduce a
\texttt{typeconstructor} variable so that we can refer to the type
recursive when we declare our constructors. And we also have acces to
the right number of polymorphic variables, matching the \texttt{Arity}
of the constructor. I like how you split out the declaration of the type
itself from the ``rest of the program'' part, this could become unwieldy
otherwise.

\heroSTUDENT{} That's what I thought too. And I see why you made the type
constructors carry their arity -- to keep types well-formed by
construction. In order to be able to actually refer to the type
constructors though, don't we need a type former:

\begin{verbatim}
tconstr : typeconstructor T \ensuremath{\to} subst typ T \ensuremath{\to} typ.
\end{verbatim}

\heroADVISOR{} We do. Also keep in mind that in a richer type system, we
probably would need an extra kind checking predicate. But this will do
for now. Let's just make sure this is fine -- I'll write down the
declaration of binary terms, to make sure we're not missing anything,
and typecheck it with Makam.

\begin{verbatim}
%type (datatype_declaration
  (fun tree \ensuremath{\Rightarrow} dbindnext (fun a \ensuremath{\Rightarrow} dbindbase
    [ (* leaf *) [],
      (* node *) [tconstr tree [a], a, tconstr tree [a]] ]))).
>> (...) : datatype_declaration (typ * unit) (constructor * constructor * unit)
\end{verbatim}

\heroSTUDENT{} Looks good. Should we proceed to actual well-formedness for
datatype declarations? I think we will need a predicate to keep track of
information about constructors -- which datatype it belongs to and what
arguments it expects. That way we can carry that information in the
assumptions context.

\begin{verbatim}
constructor_info :
  typeconstructor Arity \ensuremath{\to} constructor \ensuremath{\to} dbind typ Arity (list typ) \ensuremath{\to} prop.
\end{verbatim}

\TODO{} from here on.

\begin{verbatim}
constructor_polytypes : [Arity Ctors PolyTypes]
  subst typ Arity \ensuremath{\to}
  ctor_declaration Ctors \ensuremath{\to} subst (dbind typ Arity (list typ)) PolyTypes \ensuremath{\to} prop.

constructor_polytypes _ [] [].
constructor_polytypes TypVars (CtorType :: CtorTypes) (PolyType :: PolyTypes) :-
  applymany PolyType TypVars CtorType,
  constructor_polytypes TypVars CtorTypes PolyTypes.
\end{verbatim}

One interesting part intereaction is in the two \texttt{applymany}
calls: these are used in the opposite direction than what we have used
it so far, getting \texttt{TypVars} and \texttt{CtorType} as inputs and
producing \texttt{PolyType} as an output. We need to be careful, though,
to make sure that \texttt{PolyType} cannot capture the \texttt{TypVars}
variables:

\begin{verbatim}
wfprogram (datatype (datatype_declaration ConstructorDecls) Program') :-
  (dt:(typeconstructor T) \ensuremath{\to} ([PolyTypes]
    openmany (ConstructorDecls dt) (pfun tvars constructor_decls \ensuremath{\Rightarrow} (
      constructor_polytypes tvars constructor_decls PolyTypes)),
    openmany (Program' dt) (pfun constructors program' \ensuremath{\Rightarrow}
      assumemany (constructor_info dt) constructors PolyTypes
      (wfprogram program')))).
\end{verbatim}

In order to be able to refer to datatypes and constructors, we will need
type- and term-level formers.

\begin{verbatim}
constr : constructor \ensuremath{\to} list term \ensuremath{\to} term.

typeof (constr Constructor Args) (tconstr TypConstr TypArgs) :-
  constructor_info TypConstr Constructor PolyType,
  applymany PolyType TypArgs Typs,
  map typeof Args Typs.
\end{verbatim}

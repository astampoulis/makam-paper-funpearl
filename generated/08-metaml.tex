\section{Where our heroes tackle a new level of meta, contexts and
substitutions}\label{where-our-heroes-tackle-a-new-level-of-meta-contexts-and-substitutions}

\heroSTUDENT{} I'm fairly confident by now that Makam should be able to handle
the research idea we want to try out. Shall we get to it?

\heroADVISOR{} Yes, it is time. So, what we are aiming to do is add a facility
for type-safe, heterogeneous meta-programming to our object language,
similar to MetaHaskell \citep{mainland2012explicitly}. This way we can
manipulate the terms of a \emph{separate} object language in a type-safe
manner.

\heroSTUDENT{} Exactly. For the research language we have in mind, we aim for
our object language to be a formal logic, so our language will be
similar to Beluga \citep{beluga-main-reference} or VeriML
\citep{veriml-main-reference}. We will also need dependent functions and
pattern-matching over the object language\ldots{} But we don't need to
do all of that; let's just do a basic version for now, and I can do the
rest on my own.

\newcommand\dep[1]{\ensuremath{#1}}
\newcommand\lift[1]{\ensuremath{\langle#1\rangle}}
\newcommand\odash[0]{\ensuremath{\vdash_{\text{o}}}}
\newcommand\wf[0]{\ensuremath{\; \text{wf}}}
\newcommand\aq[1]{\ensuremath{\texttt{aq}(#1)}}
\newcommand\aqopen[1]{\ensuremath{\texttt{aqopen}(#1)}}

\heroADVISOR{} Sounds good. First, let's agree on some terminology, because a
lot of words are getting overloaded a lot. Let us call \emph{objects}
\(o\) any sorts of terms of the object language that we will be
manipulating. And, for a lack of a better word, let us call
\emph{classes} \(c\) the ``types'' that characterize those objects
through a typing relation of the form \(\Psi \odash o : c\). It is
unfortunate that these names suggest object-orientation, but this is not
the intent.

\heroSTUDENT{} I see what you are saying. Let's keep the objects simple -- to
start, let's just do the terms of the simply typed lambda calculus
(STLC). In that cases our classes will just be the types of STLC. The
objects are run-time entities: essentially, our programs will be able to
``compute'' objects. So we need a way to return (or ``lift'') an object
\(o\) as a meta-level value \(\lift{o}\).

\heroADVISOR{} Good idea. We are getting into many levels of meta -- there's
the metalanguage we're using, Makam; there's the object language we are
encoding, which is now becoming a metalanguage in itself, let's call
that Heterogeneous Meta ML Light (HMML?); and there's the
``object-object'' language that HMML is manipulating. One option would
be to have the object-object language be the full HMML metalanguage
itself, which would lead us to a homogeneous, multi-stage language like
MetaML \citep{metaml-main-reference}. But, I agree, we should keep the
object-object language simple: the STLC will suffice.

\heroSTUDENT{} Great. How about we try to do the standard example of a staged
\texttt{power} function? Here's a rough sketch, where I'm using
\texttt{\textasciitilde{}I} for antiquotation:

\begin{verbatim}
let power (n: onat): < stlc.arrow stlc.onat stlc.onat > =
  match n with
    0 \ensuremath{\Rightarrow} < stlc.lam (fun x \ensuremath{\Rightarrow} 1) >
  | S n' \ensuremath{\Rightarrow} letobj I = power n' in
      < stlc.lam (fun x \ensuremath{\Rightarrow} stlc.mult (stlc.app ~I x) x) >
\end{verbatim}

\heroADVISOR{} It's a plan. So, let's get to it. Should we write some of the
system down on paper first?

\heroSTUDENT{} Yes, that would be very useful. For this example, we will need
the lifting construct \(\lift{\cdot}\) and the \texttt{letobj} typing
rules. Here are their typing rules, which depend on an appropriately
defined typing judgment \(\Psi \odash o : c\) for objects. In our case,
this will initially match the \(\Psi; \Delta \vdash t : e\) typing
judgment for STLC. We use \(\dep{i}\) for variables standing for
objects, which we will call \emph{indices}. And we will need a way to
antiquote indices inside STLC terms, which means that we will have to
\emph{extend} the STLC terms as well as their typing judgment
accordingly. Last, I'll also write down their evaluation rules, as they
are quite simple.

\newcommand\stlce[0]{\hat{e}}
\newcommand\stlct[0]{\hat{t}}
\newcommand\stlc[1]{\hat{#1}}

\vspace{-1.5em}\begin{mathpar}
\begin{array}{ll}
\rulename{Ob-Ob-Syntax}                                                   & \rulename{HMML-Syntax} \\
\stlce  ::= \lambda x:\stlct.\stlce \; | \; \stlce_1 \; \stlce_2 \; | \; x \; | \; n \; | \; \stlce_1 * \stlce_2 \; | \; \textbf{\aq{i}} & e ::= \text{...} \; | \; \lift{\dep{o}} \; | \; \texttt{letobj} \; \dep{i} = \dep{o} \; \texttt{in} \; e \\
\stlct  ::= \stlct_1 \to \stlct_2 \; | \; \stlc{\text{nat}} & \tau ::= \text{...} \; | \; \lift{\dep{c}} \\
\dep{o} ::= \stlce \hspace{1.5em} \dep{c} ::= \stlct &
\end{array} \\

\inferrule[Typeof-LiftObj]
          {\dep{\Psi} \odash \dep{o} : \dep{c}}
          {\Gamma; \dep{\Psi} \vdash \lift{\dep{o}} : \lift{\dep{c}}}

\inferrule[Typeof-LetObj]
          {\Gamma; \dep{\Psi} \vdash e : \lift{\dep{c}} \\ \Gamma; \dep{\Psi}, \; \dep{i} : \dep{c} \vdash e : \tau \\ i \not\in \text{fv}(\tau)}
          {\Gamma; \dep{\Psi} \vdash \texttt{letobj} \; \dep{i} = e \; \texttt{in} \; e' : \tau}

\inferrule[STLC-Typeof-Antiquote]
          {\dep{i} : \stlct \in \Psi}
          {\Psi; \Delta \vdash \aq{\dep{i}} : \stlct}
          
\inferrule[Eval-LiftObj]
          {\hspace{1em}}{\lift{\dep{o}} \Downarrow \lift{\dep{o}}}

\inferrule[Eval-LetObj]
          {e \Downarrow \lift{\dep{o}} \\ e'[\dep{o}/\dep{i}] \Downarrow v}
          {\texttt{letobj} \; \dep{i} = e \; \texttt{in} \; e' \Downarrow v}

\inferrule[SubstObj]{}{
  e[\dep{o}/\dep{i}] = e' \; \text{defined by structural recursion, save for:} \; {\aq{\dep{i}}[\stlce/\dep{i}] = \stlce}
}
\end{mathpar}

The typing rules should be quite simple to transcribe to Makam:

\begin{verbatim}
object, class, index : type.
classof : object \ensuremath{\to} class \ensuremath{\to} prop.
classof_index : index \ensuremath{\to} class \ensuremath{\to} prop.
subst_obj : (I_E: index \ensuremath{\to} term) (O: object) (E_O'I: term) \ensuremath{\to} prop.

liftobj : object \ensuremath{\to} term. liftclass : class \ensuremath{\to} typ.
typeof (liftobj O) (liftclass C) :- classof O C.

letobj : term \ensuremath{\to} (index \ensuremath{\to} term) \ensuremath{\to} term.
typeof (letobj E EF') T :-
  typeof E (liftclass C), (i:index \ensuremath{\to} classof_index i C \ensuremath{\to} typeof (EF' i) T).

eval (liftobj O) (liftobj O).
eval (letobj E I_E') V :-
  eval E (liftobj O), subst_obj I_E' O E', eval E' V.
\end{verbatim}

\heroADVISOR{} Great. I'll add the object language in a separate namespace
prefix -- we can use `\texttt{\%extend}' for going into a namespace --
and I'll just copy-paste our STLC code from earlier on. Let me also add
our new antiquote as a new STLC term constructor!

\begin{verbatim}
%extend stlc.
term : type. typ : type. typeof : term \ensuremath{\to} typ \ensuremath{\to} prop.
...
aq : index \ensuremath{\to} term.
%end.
\end{verbatim}

\heroSTUDENT{} Time to add STLC terms as \texttt{object}s, and their types as
\texttt{class}es. We can then give the corresponding rule for
\texttt{classof}. And I think that's it for the typing rules!

\begin{verbatim}
obj_term : stlc.term \ensuremath{\to} object. cls_typ : stlc.typ \ensuremath{\to} class.
classof (obj_term E) (cls_typ T) :- stlc.typeof E T.
stlc.typeof (stlc.aq I) T :- classof_index I (cls_typ T).
\end{verbatim}

\begin{scenecomment}
(Hagop transcribes the example from before. Writing out the term takes several lines, so he finds himself
wishing that Makam supported some way to write terms of object languages in their native syntax;
quite curiously, he also finds himself wishing that he had a stack of blank pages.
Unbeknownst to him, his first wish has already been granted, but his second wish hasn't, so he
will have to learn about it at some later time in the future.)
\end{scenecomment}

\begin{verbatim}
typeof (letrec (bind (fun power \ensuremath{\Rightarrow} body ([ ..long term.. ], power)))) T ?
>> Yes:
>> T := arrow onat (liftclass (cls_typ (stlc.arrow stlc.onat stlc.onat))).
\end{verbatim}

\heroADVISOR{} That's great! Only thing missing to try out an evaluation
example too is implementing \texttt{subst\_obj}. Thanks to
\texttt{structural\_recursion} though, that is very easy:

\begin{verbatim}
subst_obj_aux, subst_obj_cases : [Any]
  (Var: index) (Replace: object) (Where: Any) (Result: Any) \ensuremath{\to} prop.
subst_obj I_Term O Term_O'I :-
  (i:index \ensuremath{\to} subst_obj_aux i O (I_Term i) Term_O'I).

subst_obj_aux Var Replace Where Result :-
  if (subst_obj_cases Var Replace Where Result)
  then success
  else (structural_recursion @(subst_obj_aux Var Replace) Where Result).
subst_obj_cases Var (obj_term Replace) (stlc.aq Var) Replace.
\end{verbatim}

\noindent
My definition here is quite subtle, so let me walk you through it.
First, we extend the \texttt{subst\_obj} predicate to work on any type
-- that's what \texttt{subst\_obj\_aux} is for. We set up the structural
recursion, by attempting to see whether the ``essential'' cases actually
apply -- those are captured in the \texttt{subst\_obj\_cases} predicate.
If they don't, that means we should proceed by structural recursion. I
did not mention it before, but the \texttt{@} notation that we used to
treat a polymorphic constant as a term of type \texttt{forall\ A\ T},
can be used with an arbitrary term as well, to assign it such a type if
possible. Finally, the essential case itself is a direct transcription
of the pen-and-paper version.

\heroSTUDENT{} Let me go and re-read that a little. (\ldots{}) I think it
makes sense now. Well, is that all? Are we done?

\begin{verbatim}
eval (letrec (bind (fun power \ensuremath{\Rightarrow} body ([ ..long term.. ],
        app power (osucc (osucc ozero)))))) V ?
>> Yes!!!
>> V := < obj_term (\foreignlanguage{greek}{λ}x.x * ((\foreignlanguage{greek}{λ}a.a * (\foreignlanguage{greek}{λ}b.1) a) x)) >.
\end{verbatim}

\heroADVISOR{} See, even the Makam REPL is
excited\footnote{We have taken the liberty here to transcribe the result to more meaningful syntax to make it easier to verify.}!
That looks correct, even though there are a lot of administrative
redeces. We should be able to fix that with the next kind of object in
our check-list though: open STLC terms! That way, instead of having
\texttt{power} return an object containing a lambda function, it can
return an open term. Here's how I would write the same example from
before:

\begin{verbatim}
let power_aux (n: onat): < [ stlc.onat ] stlc.onat > =
  match n with
    0 \ensuremath{\Rightarrow} < [x]. 1 >
  | S n' \ensuremath{\Rightarrow} letobj I = power_aux n' in
      < [x]. stlc.mult ~(I/[x]) x >
\end{verbatim}

\noindent
We have to list out explicitly the variables that an open term depends
on, so that's the \texttt{{[}x{]}.} notation I use. Then, we can use
contextual types \citep{nanevski2008contextual} for the type of those
open terms.

\heroSTUDENT{} Good thing I've already printed the paper out. (\ldots{}) OK,
so it says here that we can use contextual types to record, at the type
level, the context that open terms depend on. So let's say, an open
\texttt{stlc.term} of type \(t\) that mentions variables of a \(\Phi\)
context would have a contextual type of the form \([\Phi] t\). This is
some sort of modal typing, with a precise context.

\heroADVISOR{} Right. We now get to the tricky part: referring to variables
that stand for open terms within other terms! You know what those are,
right? Those are Object-level Object-level Meta-variables.

\heroSTUDENT{} My head hurts; I'm getting
\href{https://en.wikipedia.org/wiki/Out_of_memory}{OOM} errors. Maybe
this is easier to implement in Makam than to talk about.

\heroADVISOR{} Maybe so. Well, let me just say this: those variables will
stand for open terms that depend on a specific context \(\Phi\), but we
might use them at a different context \(\Phi'\). We need a
\emph{substitution} \(\sigma\) to go from the context they were defined
into the current context. I think writing down the rules on paper will
help:

\begin{mathpar}
\begin{array}{l}
\rulename{Ob-Ob-Syntax} \\
\dep{o} ::= \text{...} \; | \; [x_1, \text{...}, x_n]. \stlce \\
\dep{c} ::= \text{...} \; | \; [\stlct_1, \text{...}, \stlct_n] \stlct \\
\stlce ::= \text{...} | \; \aqopen{i}/\sigma \\
\sigma ::= [\stlce_1, \text{...}, \stlce_n]
\end{array}

\inferrule[Classof-OpenTerm]
          {\Psi; x_1 : \stlct_1, \text{...}, x_n : \stlct_n \vdash \stlce : \stlct}
          {\Psi \odash [x_1, \text{...}, x_n]. \stlce : [\stlct_1, \text{...}, \stlct_n] \stlct}

\inferrule[STLC-TypeOf-AntiquoteOpen]
          {\dep{i} : [\stlct_1, \text{...}, \stlct_n] \stlct \in \Psi \\
           \forall i.\Psi \odash \stlce_i : \stlct_i}
          {\Psi; \Delta \vdash \aqopen{\dep{i}}/[\stlce_1, \text{...}, \stlce_n] : \stlct}
          
\inferrule[SubstObj]{}{
  (\aqopen{\dep{i}}/\sigma)[[x_1, \text{...}, x_n]. \stlce / i] = \stlce[\stlce_1/x_1, \text{...}, \stlce_n/x_n] \text{ if } \sigma[[x_1, \text{...}, x_n]. \stlce / i] = [\stlce_1, \text{...}, \stlce_n]
}
\end{mathpar}

\heroSTUDENT{} I've seen that rule for \rulename{SubstObj} before, and it is
still tricky\ldots{} We need to replace the open variables in \(e\)
through the substitution
\(\sigma = [\stlce^*_1, \text{...}, \stlce^*_n]\). However, the terms
\(\stlce^*_1\) through \(\stlce^*_n\) might mention the \(i\) index
themselves, so we first need to apply the top level substitution to
\(\sigma\) itself! After that, we do replace the open variables in
\(\stlce\).

\heroADVISOR{} I feel that we are getting to the point where it's easier to
write things down in Makam rather than on paper:

\begin{verbatim}
obj_openterm : bindmany stlc.term stlc.term \ensuremath{\to} object.
cls_ctxtyp : list stlc.typ \ensuremath{\to} stlc.typ \ensuremath{\to} class.

%extend stlc.
aqopen : index \ensuremath{\to} list term \ensuremath{\to} term.
%end.

stlc.typeof (stlc.aqopen I ES) T :-
  classof_index I (cls_ctxtyp TS T),
  map stlc.typeof ES TS.

classof (obj_openterm XS_E) (cls_ctxtyp TS T) :-
  openmany XS_E (fun xs e \ensuremath{\Rightarrow}
    assumemany stlc.typeof xs TS (stlc.typeof e T)).

subst_obj_cases Var (obj_openterm Replace) (stlc.aqopen Var Subst) Result :-
  applymany Replace Subst Intermediate,
  subst_obj_aux Var (obj_openterm Replace) Intermediate Result.
\end{verbatim}

\heroSTUDENT{} I think that's all! This is exciting -- let me try it out:

\begin{verbatim}
(eq _TERM (letrec (bind (fun power \ensuremath{\Rightarrow} body ([
    lam onat (fun n \ensuremath{\Rightarrow}
    case_or_else n
      (patt_ozero) (* |\ensuremath{\to} *)
        (vbody (liftobj (obj_openterm (bind (fun x \ensuremath{\Rightarrow}
          body (stlc.osucc stlc.ozero))))))
    (case_or_else n
      (patt_osucc patt_var) (* |\ensuremath{\to} *) (vbind (fun n' \ensuremath{\Rightarrow} vbody (
         letobj (app power n') (fun i \ensuremath{\Rightarrow}
         liftobj (obj_openterm (bind (fun x \ensuremath{\Rightarrow}
           body (stlc.mult x (stlc.aqopen i [x])))))))))
      (liftobj (obj_openterm (bind (fun x \ensuremath{\Rightarrow} body stlc.ozero))))
    ))], app power (osucc (osucc ozero)))))),
  typeof _TERM T, eval _TERM V) ?
>> Yes:
>> T := liftclass (cls_ctxtyp (cons stlc.onat nil) stlc.onat),
>> V := liftobj (obj_openterm (bind (fun x \ensuremath{\Rightarrow} body (
          stlc.mult x (stlc.mult x (stlc.osucc stlc.ozero)))))).
\end{verbatim}

\noindent
It works! That's it! I cannot believe how easy this was!

\heroAUDIENCE{} We cannot possibly believe that you are claiming this was
easy!

\heroAUTHOR{} Still, try implementing something like this without a
metalanguage\ldots{} It takes a long time! As a result, it limits our
ability to experiment with and iterate on new language design ideas.
That's why I started working on Makam. That took a few years, but now we
can at least show a type system like this in 27 pages of a single-column
PDF!

\heroADVISOR{} I wonder where all these voices are coming from?

\heroSTUDENT{} Somehow, they sound like the ghosts of people who left academia
for industry.

\heroTODO{}
\textit{(Joke will be elided to avoid issues with double-blind submission.)}

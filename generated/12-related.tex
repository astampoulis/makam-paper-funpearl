\section{In which are heroes are nowhere to be found, lost in a sea of
references to related
work}\label{in-which-are-heroes-are-nowhere-to-be-found-lost-in-a-sea-of-references-to-related-work}

\identNormal

The \textbf{Racket programming language} was designed to support
creation of new programming languages \citep{racket-manifesto} and has
been used to implement a very wide variety of DSLs serving specific
purposes, including typed languages such as Typed Racket by
\citet{typed-racket-main-reference}. We believe that one of the key
characteristics of the Racket approach to language implementation is the
ability to treat code as data. Makam is largely inspired by this
approach and follows along the same lines; this is not demonstrated in
the present work to a large extent, save for the use of
\texttt{refl.assume\_get}, which turns code (the local assumptions for a
predicate) into data (a reified list of the assumptions). Still, we
believe the presence of first-class binding support in the form of
higher-order abstract syntax makes the \lamprolog setting significantly
different from Racket.

The recent development of a methodology for developing \textbf{type
systems as macros} by \citet{racket-type-systems-as-macros} is a great
validation of the Racket approach and is especially relevant to our use
case, as it has been used to encode type systems similar to ML. The
integration that this methodology provides with the rest of the Racket
ecosystem offers a number of advantages, as does the
\rulename{Turnstile} DSL for writing typing rules close to the
pen-and-paper versions. We do believe that the higher-order logic
programming setting allows for more expressivity and genericity -- for
example, we have used the same techniques to define not only typing
rules but evaluation rules as well, and it is not immediately clear to
us whether examples such as our MetaML fragment would be as easy to
implement in \rulename{Turnstile}. We are exploring an approach similar
to \rulename{Turnstile} to implement a higher-level surface language for
writing typing rules using Makam itself.

Evaluation rules can be implemented using another DSL of the Racket
ecosystem, namely \textbf{PLT Redex} \citep{felleisen2009semantics}. We
believe that staying within the same framework for both aspects offers
other advantages, especially for encoding languages where the two
aspects are more linked, such as dependently typed languages with the
conversion rule. We give one small example of that in the form of the
type synonyms example. We also find that the presence of first-class
substitution support and the support for structural recursion in Makam
offers advantages over PLT Redex.

The \textbf{Spoofax language workbench} \citep{spoofax-main-reference}
offers a series of DSLs for implementing different aspects of a
language, such as parsing, binding, typing and dynamic semantics. We
have found that some of these DSLs have restrictions that would make the
implementation of type systems similar to the ones we demonstrate in the
present work challenging. Our intention with the design of Makam as a
language prototyping tool is for it to be a single expressive core,
where all different aspects of a language can be implemented. The
\textbf{K Framework} \citep{k-framework-main-reference} is a semantics
framework based on rewriting and has been used to implement the dynamic
semantics of a wide variety of languages. It has also been shown to be
effective for the implementation of type systems
\citep{k-framework-type-systems}, treating them as abstract machines
that compute types rather than values. The recent addition of a builtin
unification procedure has made this approach significantly more
effective, allowing the definition of ML type inference; however, the
fact that \lamprolog supports higher-order unification as well renders
it applicable in further situations such as dependently typed systems.
As future work, we are exploring the design of a core calculus to aid in
the bootstrapping of a language such as Makam, and we believe that a
connection with the rewriting-logic core of the K framework will prove
beneficial in this endeavor.

\section{Where are heroes are nowhere to be found, lost in a sea of
references}\label{where-are-heroes-are-nowhere-to-be-found-lost-in-a-sea-of-references}

\identNormal

\hero{\bf Higher-order logic programming} Most of the development we
present should be easy to transcribe to other implementations of
\lamprolog like Teyjus \citep{teyjus-main-reference} and ELPI
\citep{elpi-main-reference}. Also, existing work in the same area has
considered aspects of the developments we present. Specifically:

\begin{itemize}
\tightlist
\item
  the binding constructions we present like multiple binding, patterns
  and contextual terms work in both of these implementations. The
  definition of \texttt{assumemany} is not supported in Teyjus, as it
  rests outside the fragment of hereditary Harrop formulas and breaks
  the logical properties of the language \citep{assumemany-issue};
  however, the few uses of it that we make can be inlined instead.
  Still, we have noticed a few issues with the type checker of ELPI;
  especially predicates that make use of ad-hoc polymorphism like
  \texttt{vmap} and \texttt{vopenmany} might not offer the same type
  safety as they do in Makam or Teyjus.
\item
  we have made sparing use of the runtime aspect of ad-hoc polymorphism,
  which is not supported in ELPI; one such example is the definition of
  \texttt{structural\_recursion} and the \texttt{getunif} predicate.
\item
  while standard metalogical predicates like \texttt{refl.isunif} are
  available under other names in most \lamprolog implementations,
  others, like \texttt{refl.assume\_get} are not directly supported.
  Still, we believe that they should be possible to add.
\item
  to the best of our knowledge, our use of ad-hoc polymorphism to encode
  GADTs is novel in the setting of \lamprolog, as is our definition of
  generic predicates like structural recursion
\item
  logical alternatives to various issues that we discuss are available.
  For example, the \texttt{typeq} predicate could be implemented as
  first discussed based on tabling \citep{tabling-main-reference}. Also,
  mode declarations as found in ELPI and Twelf
  \citep{twelf-main-reference} can be used instead of uses of
  \texttt{refl.isunif}, as done in our use of \texttt{typedef}. These
  features are not supported at present in Makam and are left for future
  work.
\item
  existing work that has considered the problem of ML type
  generalization in the \lamprolog setting can be found in
  \citet{typgen-lamprolog-1} and \citet{typgen-lamprolog-2}.
\item
  we make heavy use of polymorphic datatypes such as \texttt{list} and
  \texttt{bindmany}, which we believe is essential for achieving the
  conciseness that the use case of rapid prototyping demands. These are
  not supported in higher-order logic programming systems based on LF
  \citep{lf-main-reference} such as Twelf \citep{twelf-main-reference}
  and Beluga \citep{beluga-main-reference}, because they break the
  adequacy of encodings in that case. Specializing such datatypes to
  their uses should be enough to transcribe our examples that do not
  make use of meta-logical reflective predicates.
\end{itemize}

\hero{\bf Racket} The Racket programming language aims to be a language
for creating new programming languages \citep{racket-manifesto} and has
been used to implement a very wide variety of DSLs serving specific
purposes, including typed languages such as Typed Racket
\citet{typed-racket-main-reference}. We believe that one of the key
characteristics of the Racket approach to language implementation is the
ability to treat code as data. Makam is largely inspired by this
approach and follows along the same lines; this is not demonstrated in
the present work to a large extent, save for the use of
\texttt{refl.assume\_get}, which turns code (the local assumptions for a
predicate) into data (a reified list of the assumptions). Still, we
believe the presence of first-class binding support in the form of
higher-order abstract syntax makes the \lamprolog setting significantly
different from Racket. We hope that this paper explains some of the
far-reaching implications of that choice. We believe that in the future,
this same feature can be used to further elucidate and disentangle
aspects of the complex Racket syntax extension system, such as hygiene.

The recent development of a methodology for developing type systems as
macros \citet{racket-type-systems-as-macros} is a great validation of
the Racket approach and is especially relevant to our use case, as it
has been used to encode type systems similar to ML. The integration that
this methodology provides with the rest of the Racket ecosystem offers a
number of advantages, as does the \rulename{Turnstile} DSL for writing
typing rules close to the pen-and-paper versions. We do believe that the
higher-order logic programming setting allows for more expressivity and
genericity -- for example, we have used the same techniques to define
not only typing rules but evaluation rules as well. However, we are
exploring a similar approach to implement a higher-level surface
language for writing typing rules, using Makam itself.

\hero{\bf PLT/Redex}

\hero{\bf Spoofax}

\hero{\bf The K framework}

\hero{\bf CRSX}

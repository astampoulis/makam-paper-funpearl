\section{Where our heroes reflect on structural
recursion}\label{where-our-heroes-reflect-on-structural-recursion}

\heroSTUDENT{} Type synonyms? You mean, introducing type definitions like
\texttt{type\ natpair\ =\ nat\ *\ nat}? That does not seem particularly
tricky.

\heroADVISOR{} I think we will face a couple of interesting issues with it.
Let me write out the necessary pen-and-paper rules first, so that we are
on the same page. We'll do top-level type definitions, so let's add a
top-level notion of programs, and a well-formedness judgement for them.
We also need an additional environment to store type definitions:

\vspace{-1.2em}\begin{mathpar}
\inferrule[Program-Syntax]{}{c ::= \text{main} \; e \; | \; \texttt{type} \; \alpha = \tau \; ; \; c}

\inferrule[WfProgram-Main]{\emptyset; \; \Delta \vdash e : \tau}
          {\Delta \vdash (\text{main} \; e) \; \text{wf}}

\inferrule[WfProgram-Type]{\Delta, \; \alpha = \tau \vdash c \; \text{wf}}
          {\Delta \vdash (\texttt{type} \; \alpha = \tau \; ; \; c) \; \text{wf}}

\inferrule[Typeof-Conversion]
          {\Gamma; \Delta \vdash e : \tau \\ \Delta \vdash \tau =_\delta \tau'}
          {\Gamma; \Delta \vdash e : \tau'}

\inferrule[TypEq-Def]
          {\alpha = \tau \in \Delta}
          {\Delta \vdash \alpha =_\delta \tau}

\cdots
\end{mathpar}

\heroSTUDENT{} Right, we will need the conversion rule, so that we identify
types up to expanding their definitions; that's
\(\delta\)-equality\ldots{} And I see you haven't listed out all the
rules for that, but those are quite standard.

\heroADVISOR{} Still, there are quite a few of those rules. Want to give this
a try?

\heroSTUDENT{} Yes, I got this. I'll add a new \texttt{typedef} predicate; I
will only use it for local assumptions, to correspond to \(\Delta\)
context of type definitions. I will also do the well-formed program
rules:

\begin{verbatim}
typedef : (NewType: typ) (Definition: typ) \ensuremath{\to} prop.

program : type. 
main : term \ensuremath{\to} program. 
lettype : (Definition: typ) (A_Program: typ \ensuremath{\to} program) \ensuremath{\to} program.

wfprogram : program \ensuremath{\to} prop.
wfprogram (main E) :- typeof E T.
wfprogram (lettype T A_Program) :-
  (a:typ \ensuremath{\to} typedef a T \ensuremath{\to} wfprogram (A_Program a)).
\end{verbatim}

Well, I can do the conversion rule and the type equality judgement
too\ldots{}. I will name that \texttt{typeq}. I'll just write the one
rule for now, which should be sufficient for a small example:

\begin{verbatim}
typeq : (T1: typ) (T2: typ) \ensuremath{\to} prop.
typeof E T :- typeof E T', typeq T T'.
typeq A T :- typedef A T.

wfprogram (lettype (arrow onat onat) (fun a \ensuremath{\Rightarrow}
          (main (lam a (fun f \ensuremath{\Rightarrow} (app f ozero)))))) ?
>> (Complete and utter silence)
\end{verbatim}

\heroADVISOR{} Time to \texttt{Ctrl-C} out of the infinite loop?

\heroSTUDENT{} Oh. Oh, right. I guess we hit a case where the proof search
strategy of Makam fails to make progress?

\heroADVISOR{} Correct. The loop happens when the new \texttt{typeof} rule
gets triggered: it has \texttt{typeof\ E\ T\textquotesingle{}} as a
premise, but the same rule still applies to solve that goal, so the rule
will fire again, and so on. Makam just does depth-first search right
now; until my friend implements a more sophisticated search strategy, we
need to find another way to do this.

\heroSTUDENT{} I see. I guess we should switch to an algorithmic type system
then.

\heroADVISOR{} Yes. Fortunately we can do that with relatively painless edits
and additions. Consider this: we only need to use the conversion rule in
cases where we already know something about the type \texttt{T} of an
expression \texttt{E}, but the typing rules require that \texttt{E} has
a type \texttt{T\textquotesingle{}} of some other form. That was the
case above -- for \texttt{E\ =\ f}, we knew that \texttt{T\ =\ a}, but
the typing rule for \texttt{app} required that
\texttt{T\textquotesingle{}\ =\ arrow\ T1\ T2} for some \texttt{T1},
\texttt{T2}.

\heroSTUDENT{} Oh. Do you mean this in bi-directional typing terms? So, doing
type analysis of an expression with a concrete type \texttt{T} might
fail, but synthesizing the type anew could work?

\heroADVISOR{} Exactly, and in that case we have to check that the two types
are equal, using \texttt{typeq}. So we need to change the rule you wrote
to apply only in the case where \texttt{T} starts with a concrete
constructor, rather than when it is an uninstantiated unification
variable.

\heroSTUDENT{} Is that even possible? Is there a way in \foreignlanguage{greek}{Î»}Prolog to tell
whether something is a unification variable?

\heroADVISOR{} There is! Most Prolog dialects have a predicate that does that
-- it's usually called \texttt{var}. In Makam it is called
\texttt{refl.isunif}, the \texttt{refl} namespace prefix standing for
\emph{reflective} predicates. So, here's a second attempt:

\begin{verbatim}
typeof E T :- not(refl.isunif T), typeof E T', typeq T T'.
\end{verbatim}

\heroSTUDENT{} Interesting. But wouldn't this lead to an infinite loop, too?
After all, \texttt{typeq} is going to be reflexive when we add all rules
-- so we could end up in the same situation as before.

\heroADVISOR{} Correct: for every proof of
\texttt{typeof\ E\ T\textquotesingle{}} through the other rules, a new
proof using this rule will be discovered, which will lead to another
proof for it, etc. One fix is to make sure that this rule is only used
once at the end, if typing using the other rules fails. But for now,
let's do a trick to side-step this issue -- let's check that \texttt{T}
and \texttt{T\textquotesingle{}} are not identical:

\begin{verbatim}
typeof E T :- not(refl.isunif T), typeof E T', typeq T T', not(eq T T').
\end{verbatim}

\texttt{eq} is a standard-library predicate that simply attempts
unification of the two arguments:

\begin{verbatim}
eq : A \ensuremath{\to} A \ensuremath{\to} prop. eq X X.
\end{verbatim}

\heroSTUDENT{} If we ever made a paper submission out of this, the reviewers
would not be happy about this rule. But sure. We still need to define
\texttt{typeq} now; maybe I'll do this by attempting to reduce both
arguments to the same normal form.

\begin{verbatim}
typnf : A \ensuremath{\to} A \ensuremath{\to} prop.
typeq T T' :- typnf T Tnf, typnf T' Tnf.
\end{verbatim}

Oh, and we should add the conversion rule for \texttt{typeof\_patt}, but
that's almost identical as for terms. (\ldots{}) I'll do \texttt{typnf}
next.

\begin{verbatim}
typnf A T' :- typedef A T, typnf T T'.
typnf (arrow T1 T2) (arrow T1' T2') :-
  typnf T1 T1', typnf T2 T2'.
typnf (arrowmany TS T) (arrowmany TS' T') :-
  map typnf TS TS', typnf T T'.
...
\end{verbatim}

\heroADVISOR{} Writing boilerplate is not fun, is it?

\heroSTUDENT{} It is not. I wish we could just write the first rule
\texttt{typnf}; it's the only important one, after all. All the other
ones just propagate the structural recursion through. Also, whenever we
add a new constructor for types, we'll have to remember to add a
\texttt{typnf} rule for it\ldots{}.

\heroADVISOR{} Right. Let's just use some magic instead.

\begin{verbatim}
typnf : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
typnf A T' :- typedef A T, typnf T T'.
(* typnf T T' :- structural_recursion @typnf T T'. *)
\end{verbatim}

\begin{scenecomment}
(Hagop is suddenly feeling faint by what will obviously be the main point of the rest of this chapter.)
\end{scenecomment}

\heroSTUDENT{} \ldots{} What just happened. Is \texttt{structural\_recursion}
some special Makam trick I don't know about yet?

\heroADVISOR{} Indeed. There is a little bit of trickery involved here, but
you will see that there is much less of it than you would expect, upon
close reflection. \texttt{structural\_recursion} is just a normal
standard-library predicate like any other; it essentially applies a
polymorphic predicate ``structurally'' to a term. Its implementation
will be a little special of course. But let's just think about how you
would write the rest of the rules of \texttt{typnf} generically, to
perform structural recursion.

\heroSTUDENT{} OK. Well, for every top-level \texttt{typ} we visit, we
essentially need to find any \texttt{typ}s contained in it, and apply
\texttt{typnf} to them; and we would keep everything else the same.

\heroADVISOR{} Right, or equivalently, we can do this one constructor at a
time: for everything that we visit, we keep the constructor the same,
and recurse on its arguments. We'll eventually get to any \texttt{typ}s
contained, even if they're inside some other type, like in a
\texttt{list}. Something like:

\begin{verbatim}
typnf (Constructor Arguments) (Constructor Arguments') :- map typnf Arguments Arguments'.
\end{verbatim}

\heroSTUDENT{} I see! That's why you made \texttt{typnf} polymorphic above;
even if we start visiting a \texttt{typ} at the top-level, some of its
constituents might be of different type.

\heroADVISOR{} Exactly. Now, the list of \texttt{Arguments} -- can you come up
with a type for them?

\heroSTUDENT{} We can use the GADT of heterogeneous lists for them; not all
the arguments of each constructor are of the same type!

\begin{verbatim}
typenil : type. typecons : (T: type) (TS: type) \ensuremath{\to} type.
hlist : (TypeList: type) \ensuremath{\to} type.
hnil : hlist typenil. hcons : T \ensuremath{\to} hlist TS \ensuremath{\to} hlist (typecons T TS).
\end{verbatim}

\heroADVISOR{} Great! We will need a heterogeneous \texttt{map} for these
lists too. We'll need a polymorphic predicate as an argument, since
we'll have to use it for \texttt{Arguments} of different types:

\begin{verbatim}
hmap : [TS] (P: forall A (A \ensuremath{\to} A \ensuremath{\to} prop)) (XS: hlist TS) (YS: hlist TS) \ensuremath{\to} prop.
hmap P hnil hnil.
hmap P (hcons X XS) (hcons Y YS) :- apply P X Y, hmap P XS YS.
\end{verbatim}

As I mentioned before, the rank-2 polymorphism support in Makam is quite
limited, so you have to use \texttt{apply} explicitly to instantiate the
polymorphic \texttt{P} predicate accordingly and apply it.

\heroSTUDENT{} Let me try out an example of that:

\begin{verbatim}
hmap @eq (hcons 1 (hcons "foo" hnil)) YS ?
>> Yes:
>> YS := hcons 1 (hcons "foo" hnil).
\end{verbatim}

\heroSTUDENT{} Fair enough. So, going back to our generic rule -- is there a
way to actually write it? Maybe there's a reflective predicate we can
use, similar to how we used \texttt{refl.isunif} before to tell if a
term is an uninstantiated unification variable?

\heroADVISOR{} Exactly -- there is \texttt{refl.headargs}. It relates a
concrete term to its decomposition into a constructor and a list of
arguments\footnote{Other versions of Prolog have predicates toward the same effect; for example, SWI-Prolog \citep{wielemaker2012swi} provides `\texttt{compound\_{}name\_{}arguments}', which is quite similar.}.
This is not an extra-logical feature, though: we could define
\texttt{refl.headargs} without any special support, save for
\texttt{refl.isunif}, if we maintained a discipline whenever we add a
new constructor, roughly like this:

\begin{verbatim}
refl.headargs : (Term: TermT) (Head: HeadT) (Args: hlist ArgsTS) \ensuremath{\to} prop.

arrowmany : (TS: list typ) (T: typ) \ensuremath{\to} typ.
refl.headargs Term Head Args :-
  not(refl.isunif Term), eq Term (arrowmany TS T),
  eq Head arrowmany, eq Args (hcons TS (hcons T hnil)).
\end{verbatim}

\heroSTUDENT{} I see. I think I can write the generic rule for \texttt{typnf}
now then!

\begin{verbatim}
typnf T T' :-
  refl.headargs T Head Args,
  hmap @typnf Args Args',
  refl.headargs T' Head Args'.
\end{verbatim}

\heroADVISOR{} Correct. We should now be able to proceed to defining the
boilerplate generically. Let's do it as a reusable higher-order
predicate for structural recursion. I'll give you the type; you fill in
the first case:

\begin{verbatim}
structural_recursion : [B] (forall A (A \ensuremath{\to} A \ensuremath{\to} prop)) \ensuremath{\to} B \ensuremath{\to} B \ensuremath{\to} prop.
\end{verbatim}

\heroSTUDENT{} Let me see. Oh, so, the first argument -- are we doing this in
open-recursion style? Maybe that's the predicate for recursive calls. I
need to deconstruct a term, apply the recursive call\ldots{}. How is
this?

\begin{verbatim}
structural_recursion Rec X Y :-
  refl.headargs X Constructor Arguments,
  hmap Rec Arguments Arguments',
  refl.headargs Y Constructor Arguments'.
\end{verbatim}

\heroAUDIENCE{} I'm sure this was not your first attempt in the unabridged
version of this story!

\heroADVISOR{} Wait, who said that? Anyway. That looks great! And you're right
about using \texttt{refl.headargs} in the other direction, to
reconstruct a new term with the same constructor and different
arguments.

\heroSTUDENT{} Are we done?

\heroADVISOR{} Almost there! We just need to handle the case of the meta-level
function type. It does not make sense to destructure functions using
\texttt{refl.headargs}; so, that fails for functions, and we have to
treat them specially:

\begin{verbatim}
structural_recursion Rec (X : A \ensuremath{\to} B) (Y : A \ensuremath{\to} B) :-
  (x:A \ensuremath{\to} structural_recursion Rec x x \ensuremath{\to} structural_recursion Rec (X x) (Y x)).
\end{verbatim}

\begin{verbatim}
structural_recursion P X Y :- print (X, Y), refl.isunif X, not(refl.isunif Y), eq X Y.
structural_recursion P X Y :- print (X, Y, "right"), refl.isunif Y, not(refl.isunif X), eq X Y.
\end{verbatim}

\heroSTUDENT{} This is exciting; I hope it is part of the standard library of
Makam. I can do \texttt{teq} in a few lines now!

\begin{verbatim}
typnf : [A] A \ensuremath{\to} A \ensuremath{\to} prop.
typeq T T' :- not(eq T T'), typnf T Tnf, typnf T' Tnf.
typnf A T' :- typedef A T, typnf T T'.
typnf T T' :- structural_recursion @typnf T T'.
\end{verbatim}

\heroADVISOR{} That is exactly right! So, we've minimized the boilerplate, and
we won't need any adaptation when we add a new constructor -- even if we
make use of all sorts of new and complicated types.

\heroSTUDENT{} That's right: we did not do anything special for the binding
forms we defined\ldots{}. quite a payoff for a small amount of code!
But, wait, isn't \texttt{structural\_recursion} missing a case: that of
uninstantiated unification variables?

\heroADVISOR{} It is, but in my experience, it's better to define how to
handle unification variables as needed, in each new structurally
recursive predicate. In this case, we're only supposed to use
\texttt{teq} with ground terms, so it's fine if we fail when we
encounter a unification variable.

\begin{scenecomment}
(Our heroes try out a few examples and convince themselves that this works OK and no endless loops happen when things don't typecheck correctly.)
\end{scenecomment}

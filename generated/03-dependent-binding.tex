\section{Where the legend of the GADTs and the Ad-Hoc Polymorphism is
recounted}\label{where-the-legend-of-the-gadts-and-the-ad-hoc-polymorphism-is-recounted}

\identNormal\it

Once upon a time, our republic lacked one of the natural wonders that it
is now well-known for, and which is now regularly enjoyed by tourists
and inhabitants alike. I am talking of course about the Great Arboretum
of Dangling Trees, known as GADTs for short. Then settlers from the
far-away land of the Dependency started coming to the republic, and
started speaking of Lists that Knew Their Length, of Terms that Knew
Their Types, of Collections of Elements that were Heterogeneous, and
about the other magical beings of their home. And they set out to build
a natural environment for these beings on the republic, namely the GADTs
that we know and love, to remind them of home a little. And their work
was good and was admired by many.

A long time passed, and dispatches from another far-away land came to
the republic, written by authors whose names are now lost in the sea of
anonymity, and I fear might forever remain so. And the dispatches went
something like this.

\rm

\heroAUTHOR{} \ldots{} The type system in my land of \lamprolog that I speak
of is a subset of System F\(_\omega\) that should be familiar to you --
the simply typed lambda calculus, plus prenex polymorphism, plus simple
type constructors of the form
\texttt{type\ *\ ...\ *\ type\ \ensuremath{\to}\ type}. There is a
\texttt{prop} sort for propositions, which is a normal type, but also a
bit special: its terms are not just values, but are also computations,
activated when queried upon.

However, the language of this land has a distinguishing feature, called
Ad-Hoc Polymorphism. You see, the different rules that define a
predicate in our language can \emph{specialize} their type variables.
This can be used to define polymorphic predicates that behave
differently for different types, like this, where we are essentially
doing a \texttt{typecase} and we choose a rule depending on the
\emph{type} of the argument (as opposed to its value):

\begin{verbatim}
print : [A] A \ensuremath{\to} prop.
print (I: int) :- (... code for printing integers ...)
print (S: string) :- (... code for printing strings ...)
\end{verbatim}

The local dialects Teyjus
\citep{teyjus-main-reference,teyjus-2-implementation} and Makam include
this feature, while it is not encountered in other dialects like ELPI
\citep{elpi-main-reference}. In the Makam dialect in particular, type
variables are understood to be parametric by default. In order to make
them ad-hoc and allow specializing them in rules, we need to denote them
using the \texttt{{[}A{]}} notation.

Of course, this feature has both to do with the statics as well as the
dynamics of our language: and while dynamically it means something akin
to a \texttt{typecase}, statically, it means that rules might specialize
their type variables, and this remains so for type-checking the whole
rule.

But alas! Is it not type specialization during pattern matching that is
an essential feature of the GADTs of your land? Maybe that means that we
can use Ad-Hoc Polymorphism not just to do \texttt{typecase}, but also
to work with GADTs in our land? Consider this! The venerable List that
Knows Its Length:

\begin{verbatim}
zero : type. succ : type \ensuremath{\to} type.
vector : type \ensuremath{\to} type \ensuremath{\to} type.
vnil : vector A zero.
vcons : A \ensuremath{\to} vector A N \ensuremath{\to} vector A (succ N).
\end{verbatim}

And now for the essential \texttt{vmap}:

\begin{verbatim}
vmap : [N] (A \ensuremath{\to} B \ensuremath{\to} prop) \ensuremath{\to} vector A N \ensuremath{\to} vector B N \ensuremath{\to} prop.
vmap P vnil vnil.
vmap P (vcons X XS) (vcons Y YS) :- P X Y, vmap P XS YS.
\end{verbatim}

In each rule, the first argument already specializes the \texttt{N} type
-- in the first rule to \texttt{zero}, in the second, to
\texttt{succ\ N}. And so erroneous rules that do not respect this
specialization would not be accepted as a well-typed saying in our
language:

\begin{verbatim}
vmap P vnil (vcons X XS) :- ...
\end{verbatim}

And we should note that in this usage of Ad-Hoc Polymorphism for GADTs,
it is only the increased precision of the statics that we care about.
Dynamically, the rules for \texttt{vmap} can perform normal term-level
unification, and only look at the constructors \texttt{vnil} and
\texttt{vcons} to see whether each rule applies, rather than relying on
the \texttt{typecase} aspects we spoke of before.

Coupling this with the binding constructs that I talked to you earlier
about, we can build new magical beings, like the \emph{Bind that Knows
Its Length}:

\begin{verbatim}
vbindmany : (Var: type) (N: type) (Body: type) \ensuremath{\to} type.
vbody : Body \ensuremath{\to} vbindmany Var zero Body.
vbind : (Var \ensuremath{\to} vbindmany Var N Body) \ensuremath{\to} vbindmany Var (succ N) Body.
\end{verbatim}

(Whereby I am using notation of the Makam dialect in my definition of
\texttt{vbind} that allows me to name parameters, purely for the
purposes of increased clarity.)

And the \texttt{openmany} version for \texttt{vbindmany}, where the
rules are exactly as before:

\begin{verbatim}
vopenmany : [N] vbindmany Var N Body \ensuremath{\to} (vector Var N \ensuremath{\to} Body \ensuremath{\to} prop) \ensuremath{\to} prop.
vopenmany (vbody Body) Q :- Q vnil Body.
vopenmany (vbind F) Q :-
  (x:A \ensuremath{\to} vopenmany (F x) (fun xs \ensuremath{\Rightarrow} Q (vcons x xs))).
\end{verbatim}

We can also showcase the \emph{Accurate Encoding of the Letrec}:

\begin{verbatim}
vletrec : vbindmany term N (vector term N * term) \ensuremath{\to} term.
\end{verbatim}

And that is the way that the land of \lamprolog supports GADTs, without
needing the addition of any feature, all thanks to the existing support
for Ad-Hoc Polymorphism.

\identDialog

\heroTODO{}
\textcolor{red}{This is where I am! Haven't finished revising from here on.}

\heroSTUDENT{} I see. Say, can we use the same dependency trick to do
patterns?

\heroADVISOR{} We should be able to\ldots{} the linearity is going to be a bit
tricky, but I am fairly confident that having explicit support in our
metalanguage just for single-variable binding is enough to model most
complicated forms of binding, when we also make use of polymorphism and
GADTs.

\heroSTUDENT{} Makes sense. Well, I think I have an idea for patterns: we can
have a type argument to keep track of what variables they introduce.
Since within a pattern we can only refer to a variable once\ldots{} no
actual binding needs to take place. But we can use the type argument to
bind the right number of pattern variables into the body of a branch.

\heroADVISOR{} That is true\ldots{}. One way I think about binding is that it
is just a way to introduce a notion of sharing into abstract syntax
trees, so that we can refer to the same thing a number of times. And
you're right that for patterns, the sharing happens from the side of the
pattern into the branch body, not within the pattern itself.

\heroSTUDENT{} Though there is some of that in dependent pattern matching,
where you can reuse a pattern variable and an exact matching takes place
rather than unification\ldots{}.

\heroADVISOR{} \ldots{}Right. But let's not worry about that right now; let's
just do simple patterns. So at the top level, a pattern will just have a
single ``tuple type'' argument with the variables it used. I am thinking
that for sub-patterns, we will need two arguments. One for all the
variables that \emph{can} be used, initially matching the type argument
of the top-level pattern; another argument, for the variables that
\emph{remain} to be used after this sub-pattern is traversed.

\heroSTUDENT{} I don't get that yet. Wait, let me first add natural numbers as
a base type so that we have a simple example.

\begin{verbatim}
nat : typ. zero : term. succ : term \ensuremath{\to} term.
typeof zero nat. typeof (succ N) nat :- typeof N nat.
eval zero zero. eval (succ E) (succ V) :- eval E V.
\end{verbatim}

\heroADVISOR{} Good idea. OK, so here's what I meant:

\begin{verbatim}
patt : type \ensuremath{\to} type \ensuremath{\to} type.
patt_var : patt (term * T) T.
patt_zero : patt T T.
patt_succ : patt T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroSTUDENT{} Hmm. So, you said the first argument is what variables are
``available'' when we go into the sub-pattern, second is what we're
``left with''\ldots{} so in the variable case, we ``use up'' one
variable. In the zero case, we don't use any. And for successors, we
just propagate the variables.

\heroADVISOR{} Exactly. Could you do tuples?

\heroSTUDENT{} Let me see, I think I'll need a helper type for multiple
patterns\ldots{}.

\begin{verbatim}
pattlist : type \ensuremath{\to} type \ensuremath{\to} type.
nil : pattlist T T.
cons : patt T1 T2 \ensuremath{\to} pattlist T2 T3 \ensuremath{\to} pattlist T1 T3.
patt_tuple : pattlist T T' \ensuremath{\to} patt T T'.
\end{verbatim}

\heroADVISOR{} Exactly! And here's an interesting one: wildcards.

\begin{verbatim}
patt_wild : patt T T.
\end{verbatim}

\heroSTUDENT{} Oh, because that does not really introduce any pattern
variables that we can use. So if I understand this correctly, top-level
patterns should always use up all their variables -- they should end
with the second argument being \texttt{unit}, right?

\heroADVISOR{} Exactly, so this should be fine for a single-branch
pattern-match construct:

\begin{verbatim}
case_or_else : term \ensuremath{\to} patt T unit \ensuremath{\to} dbind term T term \ensuremath{\to} term \ensuremath{\to} term.
\end{verbatim}

\heroSTUDENT{} Let me parse that\ldots{} the first argument is the scrutinee,
the second is the pattern\ldots{} the third is the branch body, with the
pattern variables introduced. Oh, and the last argument is the
\texttt{else} case.

\heroADVISOR{} Right. And I think something like this should work for the
typing judgment. Let me write a few cases.

\begin{verbatim}
typeof : [T T' Ttyp T'typ] patt T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} typ \ensuremath{\to} prop.
typeof patt_var S' (cons T S') T.
typeof patt_wild S S T.
typeof patt_zero S S nat.
typeof (patt_succ P) S' S nat :- typeof P S' S nat.
\end{verbatim}

\heroSTUDENT{} I see, so given a pattern and the types of the variables
following the sub-pattern, we produce the types of all the variables and
the type of the pattern itself. Makes sense. I'll do tuples:

\begin{verbatim}
typeof : [T T' Ttyp T'typ]
  pattlist T T' \ensuremath{\to} subst typ T'typ \ensuremath{\to} subst typ Ttyp \ensuremath{\to} list typ \ensuremath{\to} prop.
typeof (patt_tuple PS) S' S (product TS) :- typeof PS S' S TS.
typeof [] S S [].
typeof (P :: PS) S3 S1 (T :: TS) :- typeof PS S3 S2 TS, typeof P S2 S1 T.
\end{verbatim}

\heroADVISOR{} Looks good. Can you do the typing rule for the case statement?

\heroSTUDENT{} How does this look?

\begin{verbatim}
typeof (case_or_else Scrutinee Pattern Body Else) T' :-
  typeof Scrutinee T,
  typeof Pattern nil TS T,
  openmany Body (pfun xs body \ensuremath{\Rightarrow} assumemany typeof xs TS (typeof body T')),
  typeof Else T'.
\end{verbatim}

\heroADVISOR{} That's great! This was a little tricky, but still, not too bad.
Actually, I know of one thing that is surprisingly simple to do: the
evaluation rule. We just have to convert a pattern into a term, where we
replace the pattern variables with \emph{meta-level} unification
variables -- then we can just reuse meta-level unification to do the
actual pattern match!

\heroSTUDENT{} Oh, that would be nice. So not only do we get variable
substitutions for free, we also get unification for free in some cases!

\heroADVISOR{} Exactly. So something like this should work:

\begin{verbatim}
patt_to_term : [T T'] patt T T' \ensuremath{\to} term \ensuremath{\to} subst term T' \ensuremath{\to} subst term T \ensuremath{\to} prop.
patt_to_term patt_var X Subst (X :: Subst).
patt_to_term patt_wild _ Subst Subst.
patt_to_term patt_zero zero Subst Subst.
patt_to_term (patt_succ PN) (succ EN) Subst' Subst :- patt_to_term PN EN Subst' Subst.
\end{verbatim}

\heroSTUDENT{} I see, interesting! So in each rule we introduce the
unification variables that we need, like \texttt{X} for the variable
case, and store them in the substitution that we will use with the
pattern body.

\begin{scenecomment}
(Our heroes also write down the rules for multiple patterns and tuples, which are
available in the unabridged version of this story.)
\end{scenecomment}

\heroADVISOR{} We should be good to write the evaluation rule now.

\begin{verbatim}
eval (case_or_else Scrutinee Pattern Body Else) V :-
  patt_to_term Pattern TermWithUnifvars [] Unifvars,
  if (eq Scrutinee TermWithUnifvars)  (* reuse unification from the meta-language *)
  then (applymany Body Unifvars Body', eval Body' V)
  else (eval Else V).
\end{verbatim}

\heroSTUDENT{} I see! So, if meta-level unification is successful, we have a
match, and we substitute the instantiations we found for the pattern
variables into the body. But you are using if-then-else? We haven't used
that so far.

\heroADVISOR{} Oh yes, I forgot to mention that. It behaves as follows: when
there is at least one way to prove the condition, it proceeds to the
\texttt{then} branch, otherwise it goes to the \texttt{else} branch.
Pretty standard really. It is one thing that the Prolog cut statement,
\texttt{!}, is useful for, but cut introduces all sorts of trouble.
\citet{kiselyov05backtracking} is worth reading for alternatives to the
cut statement and the semantics of
\texttt{if}-\texttt{then}-\texttt{else} and \texttt{not} in logic
programming, and Makam follows that closely.

\heroSTUDENT{} Noted in my to-read list. But let us try pattern matching out!
How about predecessors for natural numbers? I'll write a query that
type-checks and evaluates a couple of cases.

\begin{verbatim}
(eq _PRED (lam _ (fun n \ensuremath{\Rightarrow} case_or_else n
  (patt_succ patt_var) (dbindnext (fun pred \ensuremath{\Rightarrow} dbindbase pred))
  zero)),
 typeof _PRED T,
 eval (app _PRED zero) PRED0, eval (app _PRED (succ (succ zero))) PRED2) ?
>> Yes:
>> T := arrow nat nat, PRED0 := zero, PRED2 := succ zero.
\end{verbatim}

\heroADVISOR{} Seems to be working fine!
